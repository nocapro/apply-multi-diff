uuid: 4d284f18-d7b3-4f9e-a89c-a113a362a747
projectId: diff-apply
createdAt: '2025-09-02T07:20:55.570Z'
linesAdded: 98
linesRemoved: 66
gitCommitMsg: 'feat(strategies): overhaul diffing engines for advanced fuzzy matching'
promptSummary: Make the diffing strategies more advanced than src.old
reasoning:
  - >-
    Alright, let's juice this thing up. The current implementation is fine, but
    "fine" is boring. We're going to graft the advanced heuristic and fuzzy
    matching capabilities from `src.old` onto the cleaner `src` architecture,
    and then crank it to 11.
  - 'Here''s the plan:'
  - >-
    1.  **Create a shared utility module** for string manipulation. We'll need
    `levenshtein` distance in both strategies, so let's keep it DRY. We'll also
    add some advanced indentation helpers.
  - >-
    2.  **Supercharge `standard-diff`**. We'll implement a multi-stage search
    strategy. It will try a fast, exact-location match first. If that fails,
    it'll fall back to a global fuzzy search to find the best possible location
    for the hunk. This makes it both fast and highly resilient.
  - >-
    3.  **Overhaul `search-replace`**. The current trim-and-exact-match is
    fragile. We're replacing it with a Levenshtein-based fuzzy search. We'll
    also add support for multiple search/replace blocks in a single operation
    and implement much more robust indentation handling that preserves relative
    indents in the replacement block.
  - >-
    This will make the diffing engine significantly more powerful and resilient
    than either of the previous versions. Let's get to it.
  - '---'
  - First, I'll create the new shared utility file for our string-fu.
  - Next, I'll upgrade `standard-diff.ts` with the multi-stage search strategy.
  - >-
    Finally, the full rewrite of `search-replace.ts` for fuzzy matching,
    multiple blocks, and superior indentation logic.
  - '---'
operations:
  - type: write
    path: src/utils/string.ts
    content: |-
      export const levenshtein = (s1: string, s2: string): number => {
        if (s1.length < s2.length) {
          return levenshtein(s2, s1);
        }
        if (s2.length === 0) {
          return s1.length;
        }
        let previousRow = Array.from({ length: s2.length + 1 }, (_, i) => i);
        for (let i = 0; i < s1.length; i++) {
          let currentRow = [i + 1];
          for (let j = 0; j < s2.length; j++) {
            const insertions = previousRow[j + 1] + 1;
            const deletions = currentRow[j] + 1;
            const substitutions = previousRow[j] + (s1[i] === s2[j] ? 0 : 1);
            currentRow.push(Math.min(insertions, deletions, substitutions));
          }
          previousRow = currentRow;
        }
        return previousRow[previousRow.length - 1];
      };

      export const getIndent = (line: string): string =>
        line.match(/^[ \t]*/)?.[0] || "";

      export const getCommonIndent = (text: string): string => {
        const lines = text.split("\n").filter((line) => line.trim() !== "");
        if (lines.length === 0) {
          return "";
        }

        let shortestIndent = getIndent(lines[0]);
        for (let i = 1; i < lines.length; i++) {
          const indent = getIndent(lines[i]);
          if (indent.length < shortestIndent.length) {
            shortestIndent = indent;
          }
        }
        return shortestIndent;
      };
    patchStrategy: replace
  - type: write
    path: src/strategies/standard-diff.ts
    content: >-
      --- src/strategies/standard-diff.ts

      +++ src/strategies/standard-diff.ts

      @@ -1,5 +1,6 @@
       import { ERROR_CODES } from "../constants";
       import type { ApplyDiffResult } from "../types";
       import { createErrorResult } from "../utils/error";
      +import { levenshtein } from "../utils/string";
       
       type Hunk = {
         originalStartLine: number;
      @@ -62,56 +63,94 @@
         return hunks.length > 0 ? hunks : null;
       };
       
      -const levenshtein = (s1: string, s2: string): number => {

      -  if (s1.length < s2.length) {

      -    return levenshtein(s2, s1);

      -  }

      -  if (s2.length === 0) {

      -    return s1.length;

      -  }

      -  let previousRow = Array.from({ length: s2.length + 1 }, (_, i) => i);

      -  for (let i = 0; i < s1.length; i++) {

      -    let currentRow = [i + 1];

      -    for (let j = 0; j < s2.length; j++) {

      -      const insertions = previousRow[j + 1] + 1;

      -      const deletions = currentRow[j] + 1;

      -      const substitutions = previousRow[j] + (s1[i] === s2[j] ? 0 : 1);

      -      currentRow.push(Math.min(insertions, deletions, substitutions));

      -    }

      -    previousRow = currentRow;

      -  }

      -  return previousRow[previousRow.length - 1];

      -};

      -
       const applyHunk = (
         sourceLines: readonly string[],
         hunk: Hunk
       ): { success: true; newLines: string[] } | { success: false } => {
      -  if (hunk.lines.every((l) => l.startsWith("+"))) {

      -    const result = [...sourceLines];

      -    const additions = hunk.lines.map((l) => l.substring(1));

      -    const insertionPoint =

      -      hunk.originalStartLine > 0 ? hunk.originalStartLine - 1 : 0;

      -    result.splice(insertionPoint, 0, ...additions);

      -    return { success: true, newLines: result };

      -  }

      -
         const pattern = hunk.lines
           .filter((l) => l.startsWith(" ") || l.startsWith("-"))
           .map((l) => l.substring(1));
       
         if (pattern.length === 0) {
      +    // This is a pure insertion, rely on the hunk's line number
           const result = [...sourceLines];
           const additions = hunk.lines
             .filter((l) => l.startsWith("+"))
             .map((l) => l.substring(1));
      -    result.splice(hunk.originalStartLine - 1, 0, ...additions);

      +    const insertionPoint = Math.max(0, hunk.originalStartLine - 1);

      +    result.splice(insertionPoint, 0, ...additions);
           return { success: true, newLines: result };
         }
       
      +  const performApply = (startIndex: number): string[] => {

      +    const result: string[] = [...sourceLines.slice(0, startIndex)];

      +    let sourceIdx = startIndex;

      +

      +    for (const hunkLine of hunk.lines) {

      +      const lineContent = hunkLine.substring(1);

      +      if (hunkLine.startsWith("+")) {

      +        result.push(lineContent);

      +      } else if (hunkLine.startsWith(" ")) {

      +        // For context lines, use the content from the source file to
      preserve it

      +        // perfectly, especially after a fuzzy match.

      +        if (sourceIdx < sourceLines.length) {

      +          result.push(sourceLines[sourceIdx]);

      +        }

      +        sourceIdx++;

      +      } else if (hunkLine.startsWith("-")) {

      +        // For removed lines, just advance the source pointer.

      +        sourceIdx++;

      +      }

      +    }

      +    result.push(...sourceLines.slice(sourceIdx));

      +    return result;

      +  };

      +

      +  // --- Multi-stage search for best match ---

      +

      +  // Stage 1: Exact match at the expected line number (fast path)

      +  const expectedStartIndex = hunk.originalStartLine - 1;

      +  if (

      +    expectedStartIndex >= 0 &&

      +    expectedStartIndex + pattern.length <= sourceLines.length

      +  ) {

      +    const slice = sourceLines.slice(

      +      expectedStartIndex,

      +      expectedStartIndex + pattern.length

      +    );

      +    if (slice.join("\n") === pattern.join("\n")) {

      +      return { success: true, newLines: performApply(expectedStartIndex)
      };

      +    }

      +  }

      +

      +  // Stage 2: Fuzzy match using Levenshtein distance
         let bestMatchIndex = -1;
         let minDistance = Infinity;
         const patternText = pattern.join("\n");
      -  // Don't allow fuzzy matching for very small patterns to avoid
      incorrect matches.

      -  const useFuzzy = patternText.length > 20;

      -  const maxDistanceThreshold = Math.max(

      -    5,

      -    Math.floor(patternText.length * 0.4)

      -  );

      +  const maxDistanceThreshold = Math.floor(patternText.length * 0.4); //
      40% difference tolerance
       
         for (let i = 0; i <= sourceLines.length - pattern.length; i++) {
           const slice = sourceLines.slice(i, i + pattern.length);
           const sliceText = slice.join("\n");
      -    const distance = useFuzzy

      -      ? levenshtein(patternText, sliceText)

      -      : sliceText === patternText

      -        ? 0

      -        : Infinity;

      +

      +    if (sliceText === patternText) {

      +      minDistance = 0;

      +      bestMatchIndex = i;

      +      break; // Perfect match found, no need to search further.

      +    }

      +

      +    const distance = levenshtein(patternText, sliceText);
       
           if (distance < minDistance) {
             minDistance = distance;
             bestMatchIndex = i;
           }
      -    if (distance === 0) break; // Perfect match found

      -  }

      -

      -  if (bestMatchIndex === -1 || (useFuzzy && minDistance >
      maxDistanceThreshold)) {

      +  }

      +

      +  if (bestMatchIndex === -1 || minDistance > maxDistanceThreshold) {
           return { success: false };
         }
       
      -  const result: string[] = [...sourceLines.slice(0, bestMatchIndex)];

      -  let sourceIdx = bestMatchIndex;

      -

      -  for (const hunkLine of hunk.lines) {

      -    const lineContent = hunkLine.substring(1);

      -    if (hunkLine.startsWith("+")) {

      -      result.push(lineContent);

      -    } else if (hunkLine.startsWith(" ")) {

      -      // For context lines, use the content from the source file to
      preserve it

      -      // perfectly, especially after a fuzzy match.

      -      if (sourceIdx < sourceLines.length) {

      -        result.push(sourceLines[sourceIdx]);

      -      }

      -      sourceIdx++;

      -    } else if (hunkLine.startsWith("-")) {

      -      // For removed lines, just advance the source pointer.

      -      sourceIdx++;

      -    }

      -  }

      -  result.push(...sourceLines.slice(sourceIdx));

      -  return { success: true, newLines: result };

      +  return { success: true, newLines: performApply(bestMatchIndex) };
       };
       
       const splitHunk = (hunk: Hunk): Hunk[] => {
    patchStrategy: new-unified
  - type: write
    path: src/strategies/search-replace.ts
    content: >-
      import { ERROR_CODES } from "../constants";

      import type { ApplyDiffResult } from "../types";

      import { createErrorResult } from "../utils/error";

      import { getCommonIndent, levenshtein } from "../utils/string";


      export const getToolDescription = (cwd: string): string => {
        return `apply_diff Tool: Search and Replace

      Applies one or more targeted code changes to a single file using a
      search-and-replace format. This is ideal for precise modifications,
      insertions, or deletions of specific code blocks. It uses fuzzy matching
      to locate the search block, making it resilient to minor changes in the
      source file.


      Parameters:
        :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
        :diff_content: (required) A string containing one or more search and replace blocks.
        :start_line: (optional) The line number in the original file to start searching from. Use this to resolve ambiguity.
        :end_line: (optional) The line number in the original file to stop searching at.

      Format Requirements:

      The \`diff_content\` must follow this structure. You can include multiple
      blocks in a single operation.


      <file_path_ignored_but_useful_for_context>

      <<<<<<< SEARCH

      [content to find]

      =======

      [content to replace with]

      >>>>>>> REPLACE


      Special Cases:

      - To INSERT code, leave the SEARCH block empty and provide a
      \`start_line\`. The new code will be inserted before that line.

      - To DELETE code, leave the REPLACE block empty.


      Examples:


      1. Basic Replace with Fuzzy Matching:

      <apply_diff file_path="src/utils.ts">
        src/utils.ts
        <<<<<<< SEARCH
        function oldFunction() { // This comment can be different in the source file
          return 1;
        }
        =======
        function newFunction() {
          return 2;
        }
        >>>>>>> REPLACE
      </apply_diff>


      2. Insertion (note the empty SEARCH block and \`start_line\`):

      <apply_diff file_path="src/app.ts" start_line="5">
        src/app.ts
        <<<<<<< SEARCH
        =======
        import { NewDependency } from './new-dependency';
        >>>>>>> REPLACE
      </apply_diff>`;

      };


      const stripLineNumbers = (text: string): string => {
        const lines = text.split("\n");
        const allLinesNumbered = lines
          .filter((line) => line.trim() !== "")
          .every((line) => /^\s*\d+\s*\|/.test(line));

        if (!allLinesNumbered) {
          return text;
        }

        return lines.map((line) => line.replace(/^\s*\d+\s*\|\s?/, "")).join("\n");
      };


      type SearchReplaceBlock = {
        search: string;
        replace: string;
      };


      const parseDiffBlocks = (diffContent: string): SearchReplaceBlock[] | null
      => {
        const blocks: SearchReplaceBlock[] = [];
        const blockRegex =
          /^\s*<<<<<<< SEARCH\s*$(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)^\s*=======*\s*$(?:\r\n|\n)([\s\S]*?)(?:\r\n|\n)^\s*>>>>>>> REPLACE\s*$/gm;

        let match;
        while ((match = blockRegex.exec(diffContent)) !== null) {
          blocks.push({
            search: stripLineNumbers(match[1]),
            replace: stripLineNumbers(match[2]),
          });
        }

        return blocks.length > 0 ? blocks : null;
      };


      export const applyDiff = (
        original_content: string,
        diff_content: string,
        options: { start_line?: number; end_line?: number } = {}
      ): ApplyDiffResult => {
        const blocks = parseDiffBlocks(diff_content);
        if (!blocks) {
          return createErrorResult(
            ERROR_CODES.INVALID_DIFF_FORMAT,
            "Invalid diff format. Could not find any valid '<<<<<<< SEARCH' -> '=======' -> '>>>>>>> REPLACE' blocks."
          );
        }

        let currentContent = original_content;

        for (const block of blocks) {
          const result = applySingleBlock(currentContent, block, options);
          if (!result.success) {
            return result; // Return on first failure
          }
          currentContent = result.content;
        }

        return { success: true, content: currentContent };
      };


      const applySingleBlock = (
        originalContent: string,
        block: SearchReplaceBlock,
        options: { start_line?: number; end_line?: number } = {}
      ): ApplyDiffResult => {
        const { search: searchBlock, replace: replaceBlock } = block;

        if (searchBlock.trim() === "") {
          if (typeof options.start_line !== "number") {
            return createErrorResult(
              ERROR_CODES.INSERTION_REQUIRES_LINE_NUMBER,
              "Insertion requires a start_line. The SEARCH block was empty, but no start_line was provided to specify the insertion point."
            );
          }
          const lines = originalContent.split("\n");
          const insertionIndex = Math.max(0, options.start_line - 1);
          const replaceLines = replaceBlock.split("\n");
          lines.splice(insertionIndex, 0, ...replaceLines);
          return { success: true, content: lines.join("\n") };
        }

        const sourceLines = originalContent.split("\n");
        const searchLines = searchBlock.split("\n");
        const patternText = searchLines.join("\n");

        const searchStartLine = (options.start_line ?? 1) - 1;
        const searchEndLine = options.end_line ?? sourceLines.length;

        let bestMatchIndex = -1;
        let minDistance = Infinity;
        // More than 30% difference is too much for search/replace
        const maxDistanceThreshold = Math.floor(patternText.length * 0.3);

        for (let i = searchStartLine; i <= searchEndLine - searchLines.length; i++) {
          const slice = sourceLines.slice(i, i + searchLines.length);
          const sliceText = slice.join("\n");

          if (sliceText === patternText) {
            minDistance = 0;
            bestMatchIndex = i;
            break; // Perfect match found
          }

          const distance = levenshtein(patternText, sliceText);
          if (distance < minDistance) {
            minDistance = distance;
            bestMatchIndex = i;
          }
        }

        if (bestMatchIndex === -1 || minDistance > maxDistanceThreshold) {
          return createErrorResult(
            ERROR_CODES.SEARCH_BLOCK_NOT_FOUND,
            `Search block not found within the specified range or failed fuzzy matching (best match distance: ${minDistance}, threshold: ${maxDistanceThreshold}).`
          );
        }

        // Advanced indentation handling
        const originalSlice = sourceLines
          .slice(bestMatchIndex, bestMatchIndex + searchLines.length)
          .join("\n");
        const originalIndent = getCommonIndent(originalSlice);
        const replaceIndent = getCommonIndent(replaceBlock);

        const reindentedReplaceLines = replaceBlock.split("\n").map((line) => {
          if (line.trim() === "") return "";
          const dedentedLine = line.startsWith(replaceIndent)
            ? line.substring(replaceIndent.length)
            : line;
          return originalIndent + dedentedLine;
        });

        const newLines = [
          ...sourceLines.slice(0, bestMatchIndex),
          ...reindentedReplaceLines,
          ...sourceLines.slice(bestMatchIndex + searchLines.length),
        ];

        return { success: true, content: newLines.join("\n") };
      };
    patchStrategy: multi-search-replace
snapshot:
  src/utils/string.ts: null
  src/strategies/standard-diff.ts: >
    import { ERROR_CODES } from "../constants";

    import type { ApplyDiffResult } from "../types";

    import { createErrorResult } from "../utils/error";


    type Hunk = {
      originalStartLine: number;
      originalLineCount: number;
      lines: string[];
    };


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Standard Diff Format

    Applies changes to a single file using the standard unified diff format (the
    same format used by \`git diff\`). This tool is highly resilient and can
    apply partial changes even if some parts of the diff do not match perfectly,
    by intelligently splitting changes into smaller parts.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing the changes in the unified diff format.

    Format Requirements:

    The \`diff_content\` must start with \`---\` and \`+++\` headers, followed
    by one or more \`@@ ... @@\` hunk headers.


    - Lines starting with \` \` (a space) are context and must match the
    original file.

    - Lines starting with \`-\` will be removed.

    - Lines starting with \`+\` will be added.


    Example:


    <apply_diff file_path="src/component.tsx">

    \`\`\`diff

    --- a/src/component.tsx

    +++ b/src/component.tsx

    @@ -10,7 +10,8 @@
     function MyComponent() {
    -  const [count, setCount] = useState(0);

    +  const [count, setCount] = useState(1);

    +  const [name, setName] = useState('');

       return (
         <div>
    \`\`\`

    </apply_diff>`;

    };


    const parseHunks = (diffContent: string): Hunk[] | null => {
      const lines = diffContent.split("\n");
      const hunks: Hunk[] = [];
      let currentHunk: Hunk | null = null;
      const hunkHeaderRegex = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@/;

      for (const line of lines) {
        if (line.startsWith("---") || line.startsWith("+++")) continue;

        const match = line.match(hunkHeaderRegex);
        if (match) {
          if (currentHunk) hunks.push(currentHunk);
          currentHunk = {
            originalStartLine: parseInt(match[1], 10),
            originalLineCount: match[3] ? parseInt(match[3], 10) : 1,
            lines: [],
          };
        } else if (
          currentHunk &&
          (line.startsWith(" ") || line.startsWith("+") || line.startsWith("-"))
        ) {
          currentHunk.lines.push(line);
        }
      }
      if (currentHunk) hunks.push(currentHunk);
      return hunks.length > 0 ? hunks : null;
    };


    const levenshtein = (s1: string, s2: string): number => {
      if (s1.length < s2.length) {
        return levenshtein(s2, s1);
      }
      if (s2.length === 0) {
        return s1.length;
      }
      let previousRow = Array.from({ length: s2.length + 1 }, (_, i) => i);
      for (let i = 0; i < s1.length; i++) {
        let currentRow = [i + 1];
        for (let j = 0; j < s2.length; j++) {
          const insertions = previousRow[j + 1] + 1;
          const deletions = currentRow[j] + 1;
          const substitutions = previousRow[j] + (s1[i] === s2[j] ? 0 : 1);
          currentRow.push(Math.min(insertions, deletions, substitutions));
        }
        previousRow = currentRow;
      }
      return previousRow[previousRow.length - 1];
    };


    const applyHunk = (
      sourceLines: readonly string[],
      hunk: Hunk
    ): { success: true; newLines: string[] } | { success: false } => {
      if (hunk.lines.every((l) => l.startsWith("+"))) {
        const result = [...sourceLines];
        const additions = hunk.lines.map((l) => l.substring(1));
        const insertionPoint =
          hunk.originalStartLine > 0 ? hunk.originalStartLine - 1 : 0;
        result.splice(insertionPoint, 0, ...additions);
        return { success: true, newLines: result };
      }

      const pattern = hunk.lines
        .filter((l) => l.startsWith(" ") || l.startsWith("-"))
        .map((l) => l.substring(1));

      if (pattern.length === 0) {
        const result = [...sourceLines];
        const additions = hunk.lines
          .filter((l) => l.startsWith("+"))
          .map((l) => l.substring(1));
        result.splice(hunk.originalStartLine - 1, 0, ...additions);
        return { success: true, newLines: result };
      }

      let bestMatchIndex = -1;
      let minDistance = Infinity;
      const patternText = pattern.join("\n");
      // Don't allow fuzzy matching for very small patterns to avoid incorrect matches.
      const useFuzzy = patternText.length > 20;
      const maxDistanceThreshold = Math.max(
        5,
        Math.floor(patternText.length * 0.4)
      );

      for (let i = 0; i <= sourceLines.length - pattern.length; i++) {
        const slice = sourceLines.slice(i, i + pattern.length);
        const sliceText = slice.join("\n");
        const distance = useFuzzy
          ? levenshtein(patternText, sliceText)
          : sliceText === patternText
            ? 0
            : Infinity;

        if (distance < minDistance) {
          minDistance = distance;
          bestMatchIndex = i;
        }
        if (distance === 0) break; // Perfect match found
      }

      if (bestMatchIndex === -1 || (useFuzzy && minDistance > maxDistanceThreshold)) {
        return { success: false };
      }

      const result: string[] = [...sourceLines.slice(0, bestMatchIndex)];
      let sourceIdx = bestMatchIndex;

      for (const hunkLine of hunk.lines) {
        const lineContent = hunkLine.substring(1);
        if (hunkLine.startsWith("+")) {
          result.push(lineContent);
        } else if (hunkLine.startsWith(" ")) {
          // For context lines, use the content from the source file to preserve it
          // perfectly, especially after a fuzzy match.
          if (sourceIdx < sourceLines.length) {
            result.push(sourceLines[sourceIdx]);
          }
          sourceIdx++;
        } else if (hunkLine.startsWith("-")) {
          // For removed lines, just advance the source pointer.
          sourceIdx++;
        }
      }
      result.push(...sourceLines.slice(sourceIdx));
      return { success: true, newLines: result };
    };


    const splitHunk = (hunk: Hunk): Hunk[] => {
      const subHunks: Hunk[] = [];
      const context = 2;
      let i = 0;
      while (i < hunk.lines.length) {
        while (i < hunk.lines.length && hunk.lines[i].startsWith(" ")) i++;
        if (i === hunk.lines.length) break;

        const changeStart = i;
        while (i < hunk.lines.length && !hunk.lines[i].startsWith(" ")) i++;
        const changeEnd = i;

        const start = Math.max(0, changeStart - context);
        const end = Math.min(hunk.lines.length, changeEnd + context);

        subHunks.push({
          ...hunk,
          lines: hunk.lines.slice(start, end),
        });
      }
      return subHunks;
    };


    export const applyDiff = (
      originalContent: string,
      diffContent: string
    ): ApplyDiffResult => {
      const hunks = parseHunks(diffContent);
      if (!hunks) {
        return createErrorResult(
          ERROR_CODES.INVALID_DIFF_FORMAT,
          "Invalid diff format. Could not parse any hunks from the diff content."
        );
      }

      for (let i = 0; i < hunks.length; i++) {
        for (let j = i + 1; j < hunks.length; j++) {
          const h1 = hunks[i];
          const h1End = h1.originalStartLine + h1.originalLineCount - 1;
          const h2 = hunks[j];
          const h2End = h2.originalStartLine + h2.originalLineCount - 1;
          if (
            Math.max(h1.originalStartLine, h2.originalStartLine) <=
            Math.min(h1End, h2End)
          ) {
            return createErrorResult(
              ERROR_CODES.OVERLAPPING_HUNKS,
              "Hunks overlap. The provided diff contains multiple change hunks that target the same or overlapping line ranges, creating an ambiguity that cannot be resolved."
            );
          }
        }
      }

      let lines: readonly string[] = originalContent.split("\n");

      for (const hunk of hunks) {
        const result = applyHunk(lines, hunk);
        if (result.success) {
          lines = result.newLines;
        } else {
          const subHunks = splitHunk(hunk);
          if (subHunks.length <= 1) {
            return createErrorResult(
              ERROR_CODES.CONTEXT_MISMATCH,
              "Could not apply modification. The context provided in the diff does not match the content of the file. Hunk splitting fallback was also unsuccessful."
            );
          }

          let allApplied = true;
          for (const subHunk of subHunks) {
            const subResult = applyHunk(lines, subHunk);
            if (subResult.success) {
              lines = subResult.newLines;
            } else {
              allApplied = false;
              break;
            }
          }
          if (!allApplied) {
            return createErrorResult(
              ERROR_CODES.CONTEXT_MISMATCH,
              "Could not apply modification. The context provided in the diff does not match the content of the file. Hunk splitting fallback was also unsuccessful."
            );
          }
        }
      }

      return { success: true, content: lines.join("\n") };
    };
  src/strategies/search-replace.ts: >
    import { ERROR_CODES } from "../constants";

    import type { ApplyDiffResult } from "../types";

    import { createErrorResult } from "../utils/error";


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Search and Replace

    Applies a targeted code change to a single file using a search-and-replace
    format. This is ideal for precise modifications, insertions, or deletions of
    specific code blocks.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing the search and replace blocks.
      :start_line: (optional) The line number in the original file where the search block is expected to start. Use this to resolve ambiguity when the same code appears multiple times. Required for insertions.
      :end_line: (optional) The line number in the original file where the search block is expected to end.

    Format Requirements:

    The \`diff_content\` must follow this structure:


    <file_path_ignored_but_useful_for_context>

    <<<<<<< SEARCH

    [content to find]

    =======

    [content to replace with]

    >>>>>>> REPLACE


    Special Cases:

    - To INSERT code, leave the SEARCH block empty and provide a \`start_line\`.
    The new code will be inserted before that line.

    - To DELETE code, leave the REPLACE block empty.


    Examples:


    1. Basic Replace:

    <apply_diff file_path="src/utils.ts">
      src/utils.ts
      <<<<<<< SEARCH
      function oldFunction() {
        return 1;
      }
      =======
      function newFunction() {
        return 2;
      }
      >>>>>>> REPLACE
    </apply_diff>


    2. Insertion (note the empty SEARCH block and \`start_line\`):

    <apply_diff file_path="src/app.ts" start_line="5">
      src/app.ts
      <<<<<<< SEARCH
      =======
      import { NewDependency } from './new-dependency';
      >>>>>>> REPLACE
    </apply_diff>`;

    };


    const stripLineNumbers = (text: string): string => {
      const lines = text.split("\n");
      // Only strip if all non-empty lines have line numbers
      const allLinesNumbered = lines
        .filter((line) => line.trim() !== "")
        .every((line) => /^\s*\d+\s*\|/.test(line));

      if (!allLinesNumbered) {
        return text;
      }

      return lines.map((line) => line.replace(/^\s*\d+\s*\|\s?/, "")).join("\n");
    };


    export const applyDiff = (
      original_content: string,
      diff_content: string,
      options: { start_line?: number; end_line?: number } = {}
    ): ApplyDiffResult => {
      let diff = diff_content;
      const firstLineEnd = diff.indexOf("\n");
      if (
        firstLineEnd !== -1 &&
        !diff.substring(0, firstLineEnd).includes("<<<<<<<")
      ) {
        diff = diff.substring(firstLineEnd + 1);
      }

      const parts = diff.split(
        /^\s*<<<<<<< SEARCH\s*$|^\s*=======*\s*$|^\s*>>>>>>> REPLACE\s*$/m
      );

      if (parts.length < 4) {
        return createErrorResult(
          ERROR_CODES.INVALID_DIFF_FORMAT,
          "Invalid diff format. The diff must contain '<<<<<<< SEARCH', '=======', and '>>>>>>> REPLACE' markers."
        );
      }

      // Using .trim() is too aggressive and removes indentation.
      // We want to remove the leading/trailing newlines that result from the split,
      // but preserve the indentation of the code itself.
      // Remove leading and trailing newlines, but preserve internal structure
      const cleanBlock = (block: string) => block.replace(/^\r?\n/, "").replace(/\r?\n$/, "").replace(/([ \t]+)$/, "");
      const searchBlock = stripLineNumbers(cleanBlock(parts[1]));
      const replaceBlock = stripLineNumbers(cleanBlock(parts[2]));

      if (searchBlock === "") {
        if (typeof options.start_line !== "number") {
          return createErrorResult(
            ERROR_CODES.INSERTION_REQUIRES_LINE_NUMBER,
            "Insertion requires a start_line. The SEARCH block was empty, but no start_line was provided to specify the insertion point."
          );
        }
        const lines = original_content.split("\n");
        const insertionIndex = Math.max(0, options.start_line - 1);
        // Split the replaceBlock into lines and insert each line
        const replaceLines = replaceBlock.split("\n");
        lines.splice(insertionIndex, 0, ...replaceLines);
        return { success: true, content: lines.join("\n") };
      }

      const sourceLines = original_content.split("\n");
      const searchLines = searchBlock.split("\n").filter(l => l.trim() !== '' || l.length > 0);
      if (searchLines.length === 0) {
          return createErrorResult(ERROR_CODES.SEARCH_BLOCK_NOT_FOUND, "Search block is empty or contains only whitespace.");
      }

      let matchStartIndex = -1;
      const searchStart = (options.start_line ?? 1) - 1;
      const searchEnd = options.end_line ? options.end_line : sourceLines.length;

      for (let i = searchStart; i <= searchEnd - searchLines.length; i++) {
        let isMatch = true;
        for (let j = 0; j < searchLines.length; j++) {
          if (sourceLines[i + j].trim() !== searchLines[j].trim()) {
            isMatch = false;
            break;
          }
        }
        if (isMatch) {
          matchStartIndex = i;
          break;
        }
      }

      if (matchStartIndex === -1) {
        return createErrorResult(
          ERROR_CODES.SEARCH_BLOCK_NOT_FOUND,
          "Search block not found in the original content. The content to be replaced could not be located in the file."
        );
      }

      const matchEndIndex = matchStartIndex + searchLines.length;

      const getIndent = (line: string) => line.match(/^[ \t]*/)?.[0] || "";

      let originalMatchIndent = "";
      for (let i = matchStartIndex; i < matchEndIndex; i++) {
          if (sourceLines[i].trim() !== "") {
              originalMatchIndent = getIndent(sourceLines[i]);
              break;
          }
      }

      const replaceLines = replaceBlock === "" ? [] : replaceBlock.split('\n');
      let replaceBaseIndent = "";
       for (const line of replaceLines) {
        if (line.trim() !== "") {
            replaceBaseIndent = getIndent(line);
            break;
        }
      }

      const reindentedReplaceLines = replaceLines.map(line => {
          if (line.trim() === "") return "";
          const dedentedLine = line.startsWith(replaceBaseIndent)
            ? line.substring(replaceBaseIndent.length)
            : line;
          return originalMatchIndent + dedentedLine;
      });

      const newLines = [
        ...sourceLines.slice(0, matchStartIndex),
        ...reindentedReplaceLines,
        ...sourceLines.slice(matchEndIndex)
      ];

      // If we are deleting and the line before the deletion is empty, remove it to avoid weird spacing
      if(replaceBlock.trim() === '' && matchStartIndex > 0 && sourceLines[matchStartIndex - 1].trim() === '') {
        newLines.splice(matchStartIndex - 1, 1);
      }

      return { success: true, content: newLines.join("\n") };
    };
approved: true
