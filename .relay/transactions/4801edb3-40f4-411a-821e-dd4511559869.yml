uuid: 4801edb3-40f4-411a-821e-dd4511559869
projectId: diff-apply
createdAt: '2025-09-02T16:01:23.665Z'
linesAdded: 13
linesRemoved: 13
gitCommitMsg: 'fix(debug): export internal functions for debugging and fix type errors'
promptSummary: >-
  Fix TypeScript errors in debug.ts by exporting necessary functions and types
  from strategy modules and adding a type annotation.
reasoning:
  - >-
    ok, got a few typescript errors here. the debug harness is trying to import
    some internal functions that aren't exported. easy fix. i'll export them
    with a `_for_debug` suffix to keep the public api clean and update the
    internal calls. also, gotta fix a pesky implicit `any`.
  - >-
    let's start with `search-replace.ts`. exporting the parse and find
    functions.
  - >-
    now for `standard-diff.ts`. same deal: export `Hunk` and the internal
    functions for debugging.
  - and finally, the type annotation in `debug.ts` to make typescript happy.
  - should be all good now.
operations:
  - type: write
    path: src/strategies/search-replace.ts
    content: >-
      --- src/strategies/search-replace.ts

      +++ src/strategies/search-replace.ts

      @@ -58,7 +58,7 @@
         // a search for a blank line from an empty search block.
         // \n\n (search for blank line) -> \n
         // \n (empty search block) -> ''
      -  block.replace(/^\r?\n/, "").replace(/\r?\n$/, "");

      +  block.replace(/^\r?\n/, "").replace(/\r?\n$/, "");
       
       type SearchReplaceBlock = { search: string; replace: string };
       
      -const parseDiff = (diffContent: string): SearchReplaceBlock[] | null => {

      +export const _parseDiff_for_debug = (diffContent: string):
      SearchReplaceBlock[] | null => {
         const blocks: SearchReplaceBlock[] = [];
         const searchMarker = /^\s*<<<<<<< SEARCH\s*$/m;
         const replaceMarker = /^\s*>>>>>>> REPLACE\s*$/m;
      @@ -93,7 +93,7 @@
         return blocks.length > 0 ? blocks : null;
       };
       
      -const findBestMatch = (

      +export const _findBestMatch_for_debug = (
         sourceLines: readonly string[],
         searchLines: readonly string[],
         startLine: number,
      @@ -151,7 +151,7 @@
         diff_content: string,
         options: { start_line?: number; end_line?: number } = {}
       ): ApplyDiffResult => {
      -  const blocks = parseDiff(diff_content);

      +  const blocks = _parseDiff_for_debug(diff_content);
         if (!blocks) {
           return createErrorResult(
             ERROR_CODES.INVALID_DIFF_FORMAT,
      @@ -219,7 +219,7 @@
           // which is interpreted as two lines. We want `['']`.
           const searchLines = block.search === '\n' ? [''] : block.search.split("\n");
       
      -    const match = findBestMatch(sourceLines, searchLines,
      options.start_line ?? 1, options.end_line ?? sourceLines.length);

      +    const match = _findBestMatch_for_debug(sourceLines, searchLines,
      options.start_line ?? 1, options.end_line ?? sourceLines.length);
       
           if (match === null) {
             return createErrorResult(
    patchStrategy: new-unified
  - type: write
    path: src/strategies/standard-diff.ts
    content: >-
      --- src/strategies/standard-diff.ts

      +++ src/strategies/standard-diff.ts

      @@ -3,7 +3,7 @@
       import { createErrorResult } from "../utils/error";
       import { levenshtein } from "../utils/string";
       
      -type Hunk = {

      +export type Hunk = {
         originalStartLine: number;
         originalLineCount: number;
         newStartLine: number;
      @@ -53,7 +53,7 @@
       </apply_diff>`;
       };
       
      -const parseHunks = (diffContent: string): Hunk[] | null => {

      +export const _parseHunks_for_debug = (diffContent: string): Hunk[] | null
      => {
         const lines = diffContent.split("\n");
         const hunks: Hunk[] = [];
         let currentHunk: Omit<Hunk, 'lines'> & { lines: string[] } | null = null;
      @@ -127,7 +127,7 @@
         return result;
       };
       
      -const findAndApplyHunk = (

      +export const _findAndApplyHunk_for_debug = (
         sourceLines: readonly string[],
         hunk: Hunk
       ): { success: true; newLines: string[] } | { success: false } => {
      @@ -183,7 +183,7 @@
       };
       
       
      -const splitHunk = (hunk: Hunk): Hunk[] => {

      +export const _splitHunk_for_debug = (hunk: Hunk): Hunk[] => {
         const subHunks: Hunk[] = [];
         const context = 2; 
         let i = 0;
      @@ -211,7 +211,7 @@
         originalContent: string,
         diffContent: string
       ): ApplyDiffResult => {
      -  const hunks = parseHunks(diffContent);

      +  const hunks = _parseHunks_for_debug(diffContent);
         if (!hunks) {
           return createErrorResult(
             ERROR_CODES.INVALID_DIFF_FORMAT,
      @@ -234,18 +234,18 @@
         let appliedSuccessfully = true;
       
         for (const hunk of hunks) {
      -    const result = findAndApplyHunk(lines, hunk);

      +    const result = _findAndApplyHunk_for_debug(lines, hunk);
           if (result.success) {
             lines = result.newLines;
           } else {
             // --- FALLBACK: Hunk Splitting ---
      -      const subHunks = splitHunk(hunk);

      +      const subHunks = _splitHunk_for_debug(hunk);
             if (subHunks.length <= 1) { // No benefit in splitting a single change block
               appliedSuccessfully = false;
               break;
             }
       
             let allSubHunksApplied = true;
             for (const subHunk of subHunks) {
      -        const subResult = findAndApplyHunk(lines, subHunk);

      +        const subResult = _findAndApplyHunk_for_debug(lines, subHunk);
               if (subResult.success) {
                 lines = subResult.newLines;
               } else {
    patchStrategy: new-unified
  - type: write
    path: debug.ts
    content: |-
      --- debug.ts
      +++ debug.ts
      @@ -123,7 +123,7 @@
           const replaceBaseIndent = getCommonIndent(block.replace);
           console.log(`Replace Base Indent: '${replaceBaseIndent}' (length: ${replaceBaseIndent.length})`);
       
      -    const reindentedReplaceLines = replaceLines.map(line => {
      +    const reindentedReplaceLines = replaceLines.map((line: string) => {
             if (line.trim() === "") return "";
             const dedentedLine = line.startsWith(replaceBaseIndent)
               ? line.substring(replaceBaseIndent.length)
    patchStrategy: new-unified
snapshot:
  src/strategies/search-replace.ts: >-
    import { ERROR_CODES } from "../constants";

    import type { ApplyDiffResult } from "../types";

    import { createErrorResult } from "../utils/error";

    import { getCommonIndent, levenshtein, dedent } from "../utils/string";


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Search and Replace

    Applies a targeted code change to a single file using a search-and-replace
    format. This is ideal for precise modifications, insertions, or deletions of
    specific code blocks. It supports fuzzy matching and multiple replacements
    in a single call.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing one or more search and replace blocks.
      :start_line: (optional) The line number in the original file where the search block is expected to start. Use this to resolve ambiguity when the same code appears multiple times. Required for insertions.
      :end_line: (optional) The line number in the original file where the search block is expected to end.

    Format Requirements:

    The \`diff_content\` must follow this structure. You can include multiple
    blocks.


    <file_path_ignored_but_useful_for_context>

    <<<<<<< SEARCH

    [content to find and replace]

    =======

    [new content to insert]

    >>>>>>> REPLACE


    Special Cases:

    - To INSERT code, leave the SEARCH block empty and provide a \`start_line\`.
    The new code will be inserted before that line.

    - To DELETE code, leave the REPLACE block empty.


    Examples:


    1. Fuzzy Replace (will match even if comments are slightly different):

    <apply_diff file_path="src/utils.ts">
      src/utils.ts
      <<<<<<< SEARCH
      // old function
      function oldFunction() {
        return 1;
      }
      =======
      // new, improved function
      function newFunction() {
        return 2;
      }
      >>>>>>> REPLACE
    </apply_diff>


    2. Insertion (note the empty SEARCH block and \`start_line\`):

    <apply_diff file_path="src/app.ts" start_line="5">
      src/app.ts
      <<<<<<< SEARCH
      =======
      // Add a new configuration setting
      const newConfig = initializeNewDependency();
      >>>>>>> REPLACE
    </apply_diff>`;

    };


    const stripLineNumbers = (text: string): string => {
      const lines = text.split("\n");
      const allLinesNumbered = lines
        .filter((line) => line.trim() !== "")
        .every((line) => /^\s*\d+\s*\|/.test(line));
      if (!allLinesNumbered) return text;
      return lines.map((line) => line.replace(/^\s*\d+\s*\|\s?/, "")).join("\n");
    };


    const cleanBlock = (block: string) =>
      // Be less greedy with the trailing newline, to distinguish
      // a search for a blank line from an empty search block.
      // \n\n (search for blank line) -> \n
      // \n (empty search block) -> ''
      block.replace(/^\r?\n/, "").replace(/\r?\n$/, "");

    type SearchReplaceBlock = { search: string; replace: string };


    const parseDiff = (diffContent: string): SearchReplaceBlock[] | null => {
      const blocks: SearchReplaceBlock[] = [];
      const searchMarker = /^\s*<<<<<<< SEARCH\s*$/m;
      const replaceMarker = /^\s*>>>>>>> REPLACE\s*$/m;

      let content = diffContent;
      const firstLineEnd = content.indexOf("\n");
      if (firstLineEnd !== -1 && !content.substring(0, firstLineEnd).includes("<<<<<<<")) {
        content = content.substring(firstLineEnd + 1);
      }

      while (searchMarker.test(content)) {
        const searchStart = content.search(searchMarker);
        const replaceEndMatch = content.match(replaceMarker);
        if (!replaceEndMatch || typeof replaceEndMatch.index === "undefined") break;
        
        const replaceEnd = replaceEndMatch.index + replaceEndMatch[0].length;
        const blockContent = content.substring(searchStart, replaceEnd);
        
        const parts = blockContent.split(
          /^\s*<<<<<<< SEARCH\s*$|^\s*=======*\s*$|^\s*>>>>>>> REPLACE\s*$/m
        );
        
        if (parts.length >= 4) {
          blocks.push({
            search: stripLineNumbers(cleanBlock(parts[1])),
            replace: stripLineNumbers(cleanBlock(parts[2])),
          });
        }
        content = content.substring(replaceEnd);
      }

      return blocks.length > 0 ? blocks : null;
    };


    const findBestMatch = (
      sourceLines: readonly string[],
      searchLines: readonly string[],
      startLine: number,
      endLine: number
    ): { index: number; distance: number } | null => {
      if (searchLines.length === 0) return null;

      let bestMatchIndex = -1;
      let minDistance = Infinity;
      const searchText = searchLines.join("\n");
      const dedentedSearchText = dedent(searchText);
      // More tolerant threshold for substring-like matches and trailing comments.
      const maxDistanceThreshold = Math.max(20, Math.floor(dedentedSearchText.length * 0.7));

      const searchStart = startLine - 1;
      const searchEnd = endLine ?? sourceLines.length;

      for (let i = searchStart; i <= searchEnd - searchLines.length; i++) {
        const slice = sourceLines.slice(i, i + searchLines.length);
        const sliceText = slice.join("\n");
        const dedentedSliceText = dedent(sliceText);
        const distance = levenshtein(dedentedSearchText, dedentedSliceText);
        if (distance < minDistance) {
          minDistance = distance;
          bestMatchIndex = i;
        }
        if (distance === 0) break;
      }
      if (bestMatchIndex === -1 || minDistance > maxDistanceThreshold) {
        return null;
      }
      
      // Additional check: if a change was detected, reject if it looks like a semantic change inside a string literal
      if (minDistance > 0) {
        const slice = sourceLines.slice(bestMatchIndex, bestMatchIndex + searchLines.length);
        const sliceText = slice.join("\n");
        const dedentedSliceText = dedent(sliceText);
        
        // Check if both contain string literals and they're different
        const searchHasString = /["'].*["']/.test(dedentedSearchText);
        const sliceHasString = /["'].*["']/.test(dedentedSliceText);
        
        if (searchHasString && sliceHasString) {
          // Extract the string content to see if it's a semantic change
          const searchStringMatch = dedentedSearchText.match(/["'](.*?)["']/);
          const sliceStringMatch = dedentedSliceText.match(/["'](.*?)["']/);
          
          if (searchStringMatch && sliceStringMatch) {
            const searchString = searchStringMatch[1];
            const sliceString = sliceStringMatch[1];

            if (levenshtein(searchString, sliceString) > searchString.length * 0.5) {
              return null;
            }
          }
        }
      }
      return { index: bestMatchIndex, distance: minDistance };
    };


    export const applyDiff = (
      original_content: string,
      diff_content: string,
      options: { start_line?: number; end_line?: number } = {}
    ): ApplyDiffResult => {
      const blocks = parseDiff(diff_content);
      if (!blocks) {
        return createErrorResult(
          ERROR_CODES.INVALID_DIFF_FORMAT,
          "Invalid diff format. Could not parse any '<<<<<<< SEARCH'...'>>>>>>> REPLACE' blocks."
        );
      }

      let currentContent = original_content;

      for (const block of blocks) {
        if (block.search === "") {
          // Pure insertion
          if (typeof options.start_line !== "number") {
            return createErrorResult(
              ERROR_CODES.INSERTION_REQUIRES_LINE_NUMBER,
              "Insertion requires a start_line. A SEARCH block was empty, but no start_line was provided."
            );
          }
          // Special case for inserting into an empty file
          if (currentContent === "") {
            currentContent = block.replace;
            continue;
          }

          const lines = currentContent.split("\n");
          const insertionIndex = Math.max(0, options.start_line - 1);

          // Infer indentation from the insertion line or surrounding lines
          let indent = "";
          if (insertionIndex < lines.length) {
            const currentLineIndent = lines[insertionIndex].match(/^[ \t]*/)?.[0] || "";
            if (insertionIndex > 0) {
              const prevLineIndent = lines[insertionIndex - 1].match(/^[ \t]*/)?.[0] || "";
              const prevLineTrimmed = lines[insertionIndex-1].trim();
              // If current line is an outdent (like a closing brace), use previous line's indent
              if (prevLineIndent.length > currentLineIndent.length && lines[insertionIndex].trim().length > 0) {
                indent = prevLineIndent;
              } else if (prevLineTrimmed.endsWith('{') || prevLineTrimmed.endsWith('[') || prevLineTrimmed.endsWith('(')) {
                // If previous line opens a block, indent by 4 spaces (common practice)
                indent = prevLineIndent + '    ';
              } else {
                indent = currentLineIndent;
              }
            } else {
              indent = currentLineIndent;
            }
          } else if (lines.length > 0) {
            // If inserting at the very end, use indent of last line
            indent = lines[lines.length - 1].match(/^[ \t]*/)?.[0] || "";
          }

          const replaceLines = block.replace.split('\n');
          const replaceBaseIndent = getCommonIndent(block.replace);
          
          const reindentedReplaceLines = replaceLines.map(line => {
              if (line.trim() === "") return line;
              const dedentedLine = line.startsWith(replaceBaseIndent)
                ? line.substring(replaceBaseIndent.length)
                : line;
              return indent + dedentedLine;
          });

          lines.splice(insertionIndex, 0, ...reindentedReplaceLines);
          currentContent = lines.join("\n");
          continue;
        }

        const sourceLines = currentContent.split("\n");
        // JS `split` behavior with trailing newlines is tricky.
        // A search for a single blank line (`block.search`="\n") becomes `['', '']`,
        // which is interpreted as two lines. We want `['']`.
        const searchLines = block.search === '\n' ? [''] : block.search.split("\n");

        const match = findBestMatch(sourceLines, searchLines, options.start_line ?? 1, options.end_line ?? sourceLines.length);

        if (match === null) {
          return createErrorResult(
            ERROR_CODES.SEARCH_BLOCK_NOT_FOUND,
            "Search block not found in the original content. The content to be replaced could not be located in the file, even with fuzzy matching."
          );
        }
        
        const { index: matchStartIndex } = match;
        const matchEndIndex = matchStartIndex + searchLines.length;
        
        const sourceMatchBlock = sourceLines.slice(matchStartIndex, matchEndIndex).join('\n');
        const sourceMatchIndent = getCommonIndent(sourceMatchBlock);

        const replaceLines = block.replace ? block.replace.split('\n') : [];
        const replaceBaseIndent = getCommonIndent(block.replace);
        
        const reindentedReplaceLines = replaceLines.map(line => {
            if (line.trim() === "") return "";
            const dedentedLine = line.startsWith(replaceBaseIndent)
              ? line.substring(replaceBaseIndent.length)
              : line;
            return sourceMatchIndent + dedentedLine;
        });

        const newSourceLines = [
          ...sourceLines.slice(0, matchStartIndex),
          ...reindentedReplaceLines,
          ...sourceLines.slice(matchEndIndex)
        ];

        currentContent = newSourceLines.join("\n");
      }

      return { success: true, content: currentContent };
    };
  src/strategies/standard-diff.ts: >-
    import { ERROR_CODES } from "../constants";

    import type { ApplyDiffResult } from "../types";

    import { createErrorResult } from "../utils/error";

    import { levenshtein } from "../utils/string";


    type Hunk = {
      originalStartLine: number;
      originalLineCount: number;
      newStartLine: number;
      newLineCount: number;
      lines: string[];
    };


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Standard Diff Format

    Applies changes to a single file using the standard unified diff format.
    This tool is highly resilient and uses multiple fallback strategies (fuzzy
    matching, hunk splitting) to apply changes even if the source file has been
    modified.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing the changes in the unified diff format.

    Format Requirements:

    The \`diff_content\` must start with \`---\` and \`+++\` headers, followed
    by one or more \`@@ ... @@\` hunk headers.


    - Lines starting with \` \` (a space) are context and must match the
    original file.

    - Lines starting with \`-\` will be removed.

    - Lines starting with \`+\` will be added.


    Example:


    <apply_diff file_path="src/component.tsx">

    \`\`\`diff

    --- a/src/component.tsx

    +++ b/src/component.tsx

    @@ -10,7 +10,8 @@
     function MyComponent() {
    -  const [count, setCount] = useState(0);

    +  const [count, setCount] = useState(1);

    +  const [name, setName] = useState('');

       return (
         <div>
    \`\`\`

    </apply_diff>`;

    };


    const parseHunks = (diffContent: string): Hunk[] | null => {
      const lines = diffContent.split("\n");
      const hunks: Hunk[] = [];
      let currentHunk: Omit<Hunk, 'lines'> & { lines: string[] } | null = null;
      const hunkHeaderRegex = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@/;

      for (const line of lines) {
        if (line.startsWith("---") || line.startsWith("+++")) continue;

        const match = line.match(hunkHeaderRegex);
        if (match) {
          if (currentHunk) hunks.push(currentHunk);
          currentHunk = {
            originalStartLine: parseInt(match[1], 10),
            originalLineCount: match[3] ? parseInt(match[3], 10) : 1,
            newStartLine: parseInt(match[4], 10),
            newLineCount: match[6] ? parseInt(match[6], 10) : 1,
            lines: [],
          };
        } else if (currentHunk) {
          // Handle context lines (space prefix), additions (+), deletions (-), and empty lines
          if (line.startsWith(" ") || line.startsWith("+") || line.startsWith("-")) {
            currentHunk.lines.push(line);
          }
        }
      }
      if (currentHunk) hunks.push(currentHunk);
      return hunks.length > 0 ? hunks : null;
    };


    const applyHunkAt = (
      sourceLines: readonly string[],
      hunk: Hunk,
      startIndex: number
    ): string[] => {
      const result: string[] = [...sourceLines.slice(0, startIndex)];
      let sourceIdx = startIndex;

      for (const hunkLine of hunk.lines) {
        const lineContent = hunkLine.substring(1);
        if (hunkLine.startsWith("+")) {
          result.push(lineContent);
          continue;
        }

        // For context or deletion, find the line in the source to handle drift.
        let foundIdx = -1;
        const searchEnd = Math.min(sourceIdx + 10, sourceLines.length);
        for (let i = sourceIdx; i < searchEnd; i++) {
          if (sourceLines[i] === lineContent) {
            foundIdx = i;
            break;
          }
        }

        if (foundIdx !== -1) {
          // Found the line. Preserve drift (lines between sourceIdx and foundIdx).
          for (let i = sourceIdx; i < foundIdx; i++) {
            result.push(sourceLines[i]);
          }
          if (hunkLine.startsWith(" ")) {
            result.push(sourceLines[foundIdx]);
          }
          sourceIdx = foundIdx + 1;
        } else {
          // Not found nearby (fuzzy match case). Assume current line corresponds.
          if (hunkLine.startsWith(" ")) {
            if (sourceIdx < sourceLines.length) result.push(sourceLines[sourceIdx]);
          }
          sourceIdx++;
        }
      }
      result.push(...sourceLines.slice(sourceIdx));
      return result;
    };


    const findAndApplyHunk = (
      sourceLines: readonly string[],
      hunk: Hunk
    ): { success: true; newLines: string[] } | { success: false } => {
      const pattern = hunk.lines
        .filter((l) => l.startsWith(" ") || l.startsWith("-"))
        .map((l) => l.substring(1));

      if (pattern.length === 0) {
        // Pure insertion. Trust the line number.
        // A pure insertion hunk's originalStartLine refers to the line *after* which
        // the content should be inserted. Line `n` is at index `n-1`. After line `n` is index `n`.
        const insertionPoint = hunk.originalStartLine;
        const result = [...sourceLines];
        const additions = hunk.lines
          .filter((l) => l.startsWith("+"))
          .map((l) => l.substring(1));
        result.splice(insertionPoint, 0, ...additions);
        return { success: true, newLines: result };
      }

      // --- STAGE 1: Exact Match (Fast Path) ---
      const expectedStartIndex = hunk.originalStartLine - 1;
      if (expectedStartIndex >= 0 && expectedStartIndex + pattern.length <= sourceLines.length) {
        const slice = sourceLines.slice(expectedStartIndex, expectedStartIndex + pattern.length);
        if (slice.join("\n") === pattern.join("\n")) {
          return { success: true, newLines: applyHunkAt(sourceLines, hunk, expectedStartIndex) };
        }
      }

      // --- STAGE 2: Fuzzy Match (Global Search) ---
      let bestMatchIndex = -1;
      let minDistance = Infinity;
      const patternText = pattern.join("\n");
      const maxDistanceThreshold = Math.floor(patternText.length * 0.30); // 30% difference tolerance

      for (let i = 0; i <= sourceLines.length - pattern.length; i++) {
        const sliceText = sourceLines.slice(i, i + pattern.length).join("\n");
        const distance = levenshtein(patternText, sliceText);
        if (distance < minDistance) {
          minDistance = distance;
          bestMatchIndex = i;
        }
        if (distance === 0) break; // Perfect match found
      }

      if (bestMatchIndex !== -1 && minDistance <= maxDistanceThreshold) {
        return { success: true, newLines: applyHunkAt(sourceLines, hunk, bestMatchIndex) };
      }

      return { success: false };
    };



    const splitHunk = (hunk: Hunk): Hunk[] => {
      const subHunks: Hunk[] = [];
      const context = 2; 
      let i = 0;
      while (i < hunk.lines.length) {
        // Skip leading context
        while (i < hunk.lines.length && hunk.lines[i].startsWith(" ")) i++;
        if (i === hunk.lines.length) break;

        const changeBlockStart = i;
        // Find end of this change block
        while (i < hunk.lines.length && !hunk.lines[i].startsWith(" ")) i++;
        const changeBlockEnd = i;

        const subHunkStart = Math.max(0, changeBlockStart - context);
        const subHunkEnd = Math.min(hunk.lines.length, changeBlockEnd + context);
        
        const subHunkLines = hunk.lines.slice(subHunkStart, subHunkEnd);

        subHunks.push({
          ...hunk, // Carry over metadata, although it's less accurate for sub-hunks
          lines: subHunkLines,
        });
      }
      return subHunks;
    };


    export const applyDiff = (
      originalContent: string,
      diffContent: string
    ): ApplyDiffResult => {
      const hunks = parseHunks(diffContent);
      if (!hunks) {
        return createErrorResult(
          ERROR_CODES.INVALID_DIFF_FORMAT,
          "Invalid diff format. Could not parse any hunks."
        );
      }
      
      // Basic validation for overlapping hunks
      for (let i = 0; i < hunks.length; i++) {
        for (let j = i + 1; j < hunks.length; j++) {
          const h1 = hunks[i];
          const h1End = h1.originalStartLine + h1.originalLineCount;
          const h2 = hunks[j];
          if (Math.max(h1.originalStartLine, h2.originalStartLine) < Math.min(h1End, h2.originalStartLine + h2.originalLineCount)) {
            return createErrorResult(ERROR_CODES.OVERLAPPING_HUNKS, "Hunks overlap, which is not supported.");
          }
        }
      }

      let lines: readonly string[] = originalContent.split("\n");
      let appliedSuccessfully = true;

      for (const hunk of hunks) {
        const result = findAndApplyHunk(lines, hunk);
        if (result.success) {
          lines = result.newLines;
        } else {
          // --- FALLBACK: Hunk Splitting ---
          const subHunks = splitHunk(hunk);
          if (subHunks.length <= 1) { // No benefit in splitting a single change block
            appliedSuccessfully = false;
            break;
          }

          let allSubHunksApplied = true;
          for (const subHunk of subHunks) {
            const subResult = findAndApplyHunk(lines, subHunk);
            if (subResult.success) {
              lines = subResult.newLines;
            } else {
              allSubHunksApplied = false;
              break;
            }
          }

          if (!allSubHunksApplied) {
            appliedSuccessfully = false;
            break;
          }
        }
      }

      if (!appliedSuccessfully) {
        return createErrorResult(
          ERROR_CODES.CONTEXT_MISMATCH,
          "Could not apply modification. A hunk could not be matched, even with fuzzy search and hunk splitting fallbacks."
        );
      }

      return { success: true, content: lines.join("\n") };
    };
  debug.ts: >
    import fs from "fs";

    import path from "path";

    import yaml from "js-yaml";

    import {
      applyDiff as applySearchReplace,
      _parseDiff_for_debug,
      _findBestMatch_for_debug,
    } from "./src/strategies/search-replace";

    import {
      applyDiff as applyStandardDiff,
      _parseHunks_for_debug,
      _findAndApplyHunk_for_debug,
      _splitHunk_for_debug,
      type Hunk,
    } from "./src/strategies/standard-diff";

    import { getCommonIndent, dedent } from './src/utils/string';


    // --- Types from tests ---

    interface ApplyDiffTestCase {
      name: string;
      description: string;
      input: {
        original_content: string;
        diff_content: string;
        start_line?: number;
        end_line?: number;
      };
      expected: {
        success: boolean;
        content?: string;
        reason?: string;
      };
    }


    interface TestFixtures {
      apply_diff_tests: ApplyDiffTestCase[];
    }


    // --- Helper to load fixtures ---

    const loadFixturesFromDir = (dirPath: string): ApplyDiffTestCase[] => {
      let allTests: ApplyDiffTestCase[] = [];
      const files = fs.readdirSync(dirPath);
      for (const file of files) {
        if (path.extname(file) === ".yml" || path.extname(file) === ".yaml") {
          const filePath = path.join(dirPath, file);
          const fixture = yaml.load(
            fs.readFileSync(filePath, "utf-8")
          ) as Partial<TestFixtures>;
          if (fixture.apply_diff_tests) {
            allTests.push(...fixture.apply_diff_tests);
          }
        }
      }
      return allTests;
    };


    // --- Test Cases ---

    const searchReplaceFixtures = loadFixturesFromDir(
      path.join(__dirname, "test/fixtures/search-replace")
    );

    const standardDiffFixtures = loadFixturesFromDir(
      path.join(__dirname, "test/fixtures/standard-diff")
    );


    // --- CONFIGURATION ---

    const FAILING_SEARCH_REPLACE_TESTS = [
      'fuzzy-match-accept-minor-string-literal-change', // Loses trailing comment
      'replace-with-regex-special-chars', // Loses prefix/suffix on same line
      'remove-extra-blank-lines', // Fails to find a single blank line
      'unicode-characters-replace', // Loses prefix/suffix on same line
      'constrained-search-with-end-line', // Incorrectly replaces line
    ];


    const FAILING_STANDARD_DIFF_TESTS = [
      'hunk-splitting-failure', // A sub-hunk fails to apply
      'add-to-file-without-trailing-newline', // Doesn't add trailing newline when needed
      'large-hunk-split-with-fuzzy-subhunks', // A fuzzy sub-hunk fails to apply
    ];


    const TEST_TO_RUN = FAILING_SEARCH_REPLACE_TESTS[0]; // <-- CHANGE INDEX TO
    DEBUG DIFFERENT TESTS

    const STRATEGY: "search-replace" | "standard-diff" = "search-replace";


    // --- Deep Debugger for Search/Replace ---

    const debugSearchReplace = (testCase: ApplyDiffTestCase) => {
      console.log('--- DEEP DEBUG: SEARCH/REPLACE ---');
      const { original_content, diff_content, start_line, end_line } = testCase.input;
      const options = { start_line, end_line };

      console.log('\n[1] Parsing Diff Content...');
      const blocks = _parseDiff_for_debug(diff_content);
      if (!blocks) { console.error('Failed to parse blocks.'); return; }
      console.log(`Found ${blocks.length} block(s).`);

      let currentContent = original_content;

      for (let i = 0; i < blocks.length; i++) {
        const block = blocks[i];
        console.log(`\n--- Processing Block ${i + 1} ---`);
        console.log('Search Block:\n---', `\n${block.search}`, '\n---');
        console.log('Replace Block:\n---', `\n${block.replace}`, '\n---');

        if (block.search === "") { console.log('Skipping deep debug for insertion block.'); continue; }

        const sourceLines = currentContent.split("\n");
        const searchLines = block.search.split("\n");

        console.log('\n[2] Finding Best Match...');
        const match = _findBestMatch_for_debug(sourceLines, searchLines, options.start_line ?? 1, options.end_line ?? sourceLines.length);

        if (!match) { console.error('No match found.'); continue; }
        console.log(`Match found: index=${match.index}, distance=${match.distance}`);

        const { index: matchStartIndex } = match;
        const matchEndIndex = matchStartIndex + searchLines.length;

        console.log('\n[3] Preparing Replacement...');
        const sourceMatchBlock = sourceLines.slice(matchStartIndex, matchEndIndex).join('\n');
        const sourceMatchIndent = getCommonIndent(sourceMatchBlock);
        console.log(`Source Match Block (at index ${matchStartIndex}):\n---`, `\n${sourceMatchBlock}`, '\n---');
        console.log(`Inferred Indent: '${sourceMatchIndent}' (length: ${sourceMatchIndent.length})`);

        const replaceLines = block.replace ? block.replace.split('\n') : [];
        const replaceBaseIndent = getCommonIndent(block.replace);
        console.log(`Replace Base Indent: '${replaceBaseIndent}' (length: ${replaceBaseIndent.length})`);

        const reindentedReplaceLines = replaceLines.map(line => {
          if (line.trim() === "") return "";
          const dedentedLine = line.startsWith(replaceBaseIndent)
            ? line.substring(replaceBaseIndent.length)
            : line;
          return sourceMatchIndent + dedentedLine;
        });

        console.log('Re-indented Replace Lines:\n---', `\n${reindentedReplaceLines.join('\n')}`, '\n---');

        console.log('\n[4] Applying Slice...');
        console.log(`Splicing out ${matchEndIndex - matchStartIndex} line(s) from index ${matchStartIndex}.`);
      }
    };


    // --- Deep Debugger for Standard Diff ---

    const debugStandardDiff = (testCase: ApplyDiffTestCase) => {
      console.log('--- DEEP DEBUG: STANDARD DIFF ---');
      const { original_content, diff_content } = testCase.input;

      console.log('\n[1] Parsing Hunks...');
      const hunks = _parseHunks_for_debug(diff_content);
      if (!hunks) { console.error('Failed to parse hunks.'); return; }
      console.log(`Found ${hunks.length} hunk(s).`);

      let lines: readonly string[] = original_content.split("\n");

      for (const hunk of hunks) {
        console.log(`\n--- Processing Hunk (original line ${hunk.originalStartLine}) ---`);
        console.log(hunk.lines.join('\n'));

        console.log('\n[2] Applying Hunk...');
        const result = _findAndApplyHunk_for_debug(lines, hunk);
        if (result.success) {
          console.log('Hunk applied successfully.');
          lines = result.newLines;
        } else {
          console.log('Hunk application failed. Attempting to split...');
          const subHunks = _splitHunk_for_debug(hunk);
          if (subHunks.length <= 1) {
            console.log('Could not split hunk further. Failing.');
            break;
          }
          console.log(`Split into ${subHunks.length} sub-hunk(s).`);
          for (const subHunk of subHunks) {
            console.log('\n-- Applying Sub-Hunk --');
            console.log(subHunk.lines.join('\n'));
            const subResult = _findAndApplyHunk_for_debug(lines, subHunk);
            if (subResult.success) {
              console.log('Sub-hunk applied successfully.');
              lines = subResult.newLines;
            } else {
              console.error('Sub-hunk failed to apply. Aborting split.');
              break;
            }
          }
        }
      }
    };



    // --- Runner ---

    const runTest = () => {
      const isSr = STRATEGY === "search-replace";
      const fixtures = isSr ? searchReplaceFixtures : standardDiffFixtures;
      const testCase = fixtures.find((t) => t.name === TEST_TO_RUN);

      if (!testCase) {
        console.error(`Test case "${TEST_TO_RUN}" not found in ${STRATEGY} fixtures.`);
        return;
      }

      console.log(`--- Running Test: ${testCase.name} ---`);
      console.log(`Description: ${testCase.description}\n`);

      isSr ? debugSearchReplace(testCase) : debugStandardDiff(testCase);

      const applyFn = isSr ? applySearchReplace : applyStandardDiff;

      // @ts-ignore
      const result = applyFn(
        testCase.input.original_content,
        testCase.input.diff_content,
        { start_line: testCase.input.start_line, end_line: testCase.input.end_line }
      );

      console.log("\n\n--- EXPECTED ---");
      console.log(JSON.stringify(testCase.expected, null, 2));
      console.log("\n\n--- ACTUAL ---");
      console.log(JSON.stringify(result, null, 2));

      console.log("\n\n--- COMPARISON ---");
      if (result.success !== testCase.expected.success) {
        console.log(`❌ Success mismatch: expected ${testCase.expected.success}, got ${result.success}`);
      } else {
        console.log(`✅ Success matches: ${result.success}`);
      }

      if (result.success && testCase.expected.success) {
        if (result.content !== testCase.expected.content) {
          console.log("❌ Content mismatch!");
          console.log("--- Expected Content ---", JSON.stringify(testCase.expected.content));
          console.log("--- Actual Content ---", JSON.stringify(result.content));
        } else {
          console.log("✅ Content matches!");
        }
      }

      if (!result.success && !testCase.expected.success && testCase.expected.reason) {
        if (!result.error.message.includes(testCase.expected.reason)) {
          console.log(`❌ Reason mismatch: expected to include "${testCase.expected.reason}", got "${result.error.message}"`);
        } else {
          console.log(`✅ Reason matches.`);
        }
      }
    };


    runTest();
approved: true
