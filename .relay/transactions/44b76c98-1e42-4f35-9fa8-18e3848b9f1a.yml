uuid: 44b76c98-1e42-4f35-9fa8-18e3848b9f1a
projectId: diff-apply
createdAt: '2025-09-02T15:31:13.324Z'
linesAdded: 1263
linesRemoved: 1168
gitCommitMsg: 'refactor(tests): reorganize fixtures and add robust test cases'
promptSummary: >-
  Refactor test fixtures into a directory structure, add more significant test
  cases for both diffing strategies, and improve the indentation inference logic
  for search-replace insertions.
reasoning:
  - >-
    k, hacker. refactoring tests and adding more significant cases. smart move.
    also improving indentation logic for insertions. let's get it done.
  - First, I'll delete the old monolithic fixture files.
  - >-
    Now, I'll create the new directory structure for fixtures and populate them.
    I'll start with the `standard-diff` fixtures.
  - This one contains general success cases.
  - >-
    This file is for the fuzzy matching and hunk splitting logic, including the
    new complex case.
  - This file isolates expected failures.
  - >-
    This file covers edge cases like empty files, unicode, and pure
    insertions/deletions.
  - This is for the tool description tests.
  - Now for the `search-replace` fixtures.
  - Now, I'll update the test files to load fixtures from the new directories.
  - >-
    Finally, I'll patch `search-replace.ts` with the improved indentation logic
    for insertions.
  - Job's done. Test suite is stronger and more organized. Code is better.
operations:
  - type: delete
    path: test/fixtures/search-replace.yml
  - type: delete
    path: test/fixtures/standard-diff.yml
  - type: write
    path: test/fixtures/standard-diff/success.yml
    content: |-
      # Tests for successful application of standard diffs
      apply_diff_tests:
        - name: simple-modification
          description: Should apply a simple modification, addition, and deletion correctly
          input:
            original_content: |
              line1
              line2
              line3
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,3 +1,4 @@
               line1
              +new line
               line2
              -line3
              +modified line3
          expected:
            success: true
            content: |
              line1
              new line
              line2
              modified line3

        - name: multiple-hunks
          description: Should correctly apply a diff with multiple, non-contiguous hunks
          input:
            original_content: |
              line1
              line2
              line3
              line4
              line5
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,2 +1,2 @@
               line1
              -line2
              +modified line2
              @@ -4,2 +4,2 @@
               line4
              -line5
              +modified line5
          expected:
            success: true
            content: |
              line1
              modified line2
              line3
              line4
              modified line5

        - name: correct-modification-with-similar-code
          description: Should correctly modify the right section when similar code exists elsewhere
          input:
            original_content: |
              function add(a, b) {
                return a + b;
              }

              function multiply(a, b) {
                return a + b;  // Bug here
              }
            diff_content: |
              --- a/math.js
              +++ b/math.js
              @@ -5,3 +5,3 @@
               function multiply(a, b) {
              -  return a + b;  // Bug here
              +  return a * b;
               }
          expected:
            success: true
            content: |
              function add(a, b) {
                return a + b;
              }

              function multiply(a, b) {
                return a * b;
              }

        - name: handle-indentation-changes
          description: Should correctly handle changes involving different types of indentation
          input:
            original_content: |
              function example() {
                let a = 1;
                  let b = 2;
              }
            diff_content: |
              --- a/file.js
              +++ b/file.js
              @@ -1,4 +1,5 @@
               function example() {
                 let a = 1;
              +  // new line
                   let b = 2;
               }
          expected:
            success: true
            content: |
              function example() {
                let a = 1;
                // new line
                  let b = 2;
              }

        - name: handle-empty-lines-modification
          description: Should correctly apply changes that involve empty lines
          input:
            original_content: |
              line1

              line3
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,3 +1,3 @@
               line1
               
              -line3
              +line3-modified
          expected:
            success: true
            content: |
              line1

              line3-modified
    patchStrategy: replace
  - type: write
    path: test/fixtures/standard-diff/fuzzy.yml
    content: |-
      # Tests for fuzzy matching and hunk splitting
      apply_diff_tests:
        - name: fuzzy-match-with-drifted-context
          description: Should apply a hunk correctly even if the context has minor changes
          input:
            original_content: |
              // SPDX-License-Identifier: MIT
              pragma solidity ^0.8.20;

              contract SimpleStore {
                  uint256 private _value; // The value stored

                  function setValue(uint256 value) public {
                      _value = value;
                  }
              }
            diff_content: |
              --- a/SimpleStore.sol
              +++ b/SimpleStore.sol
              @@ -3,6 +3,10 @@
               
               contract SimpleStore {
                   uint256 private _value; // The value stored
              +
              +    function getValue() public view returns (uint256) {
              +        return _value;
              +    }
               
                   function setValue(uint256 value) public {
                       _value = value;
          expected:
            success: true
            content: |
              // SPDX-License-Identifier: MIT
              pragma solidity ^0.8.20;

              contract SimpleStore {
                  uint256 private _value; // The value stored

                  function getValue() public view returns (uint256) {
                      return _value;
                  }

                  function setValue(uint256 value) public {
                      _value = value;
                  }
              }

        - name: fallback-hunk-splitting-on-failure
          description: Should split a failing hunk into smaller parts and apply them individually
          input:
            original_content: |
              import { readFile } from 'fs';
              import { Logger } from './logger';

              const logger = new Logger();

              async function processFile(filePath: string) {
                try {
                  const data = await readFile(filePath, 'utf8');
                  logger.info('File read successfully');
                  return data;
                } catch (error) {
                  logger.error('Failed to read file:', error);
                  throw error;
                }
              }
            diff_content: |
              --- a/file.ts
              +++ b/file.ts
              @@ -1,13 +1,13 @@
               import { readFile } from 'fs';
              -import { Logger } from './logger';
              +import { Logger } from './utils/logger';
               
               const logger = new Logger(); // This context line is correct
               
               async function processFile(filePath: string) { // This context line is also correct
                 try {
                   const data = await readFile(filePath, 'utf8');
              -    logger.info('File read successfully');
              +    logger.info(`File ${filePath} read successfully`);
                   return data;
                 } catch (error) {
                   logger.error('Failed to read file:', error);
                   throw error;
                 }
               }
          expected:
            success: true
            content: |
              import { readFile } from 'fs';
              import { Logger } from './utils/logger';

              const logger = new Logger();

              async function processFile(filePath: string) {
                try {
                  const data = await readFile(filePath, 'utf8');
                  logger.info(`File ${filePath} read successfully`);
                  return data;
                } catch (error) {
                  logger.error('Failed to read file:', error);
                  throw error;
                }
              }
        - name: fuzzy-match-with-actual-drift
          description: Should apply a hunk using fuzzy matching when context has drifted due to new comments
          input:
            original_content: |
              // User added a comment here
              class MyComponent extends React.Component {
                render() {
                  const { value } = this.props;
                  // And another comment here
                  return <div>{value}</div>;
                }
              }
            diff_content: |
              --- a/component.jsx
              +++ b/component.jsx
              @@ -2,5 +2,5 @@
               class MyComponent extends React.Component {
                 render() {
                   const { value } = this.props;
              -    return <div>{value}</div>;
              +    return <p>{value}</p>;
                 }
               }
          expected:
            success: true
            content: |
              // User added a comment here
              class MyComponent extends React.Component {
                render() {
                  const { value } = this.props;
                  // And another comment here
                  return <p>{value}</p>;
                }
              }

        - name: hunk-splitting-with-intermediate-user-edit
          description: Should succeed by splitting a hunk when a user edit breaks its contiguity
          input:
            original_content: |
              function setup() {
                  console.log("Initializing part 1...");
                  // init
              }

              // User added a new function here, breaking the hunk's contiguity
              function helper() {
                  return true;
              }

              function tearDown() {
                  console.log("Tearing down part 3...");
                  // teardown
              }
            diff_content: |
              --- a/file.js
              +++ b/file.js
              @@ -1,8 +1,8 @@
               function setup() {
              -    console.log("Initializing part 1...");
              -    // init
              +    console.log("Initializing part 1... DONE");
              +    // initialize
               }
               
               function tearDown() {
              -    console.log("Tearing down part 3...");
              -    // teardown
              +    console.log("Tearing down part 3... DONE");
              +    // deinitialize
               }
          expected:
            success: true
            content: |
              function setup() {
                  console.log("Initializing part 1... DONE");
                  // initialize
              }

              // User added a new function here, breaking the hunk's contiguity
              function helper() {
                  return true;
              }

              function tearDown() {
                  console.log("Tearing down part 3... DONE");
                  // deinitialize
              }

        - name: hunk-splitting-with-fuzzy-sub-hunk
          description: Should split a hunk and then fuzzy-match a sub-hunk
          input:
            original_content: |
              function partA() {
                  // original A content
                  // another line in A
              }

              // User added this function, breaking the hunk
              function partB_user_added() {}

              // User also modified this part slightly
              function partC_modified_by_user() { // modified
                  // original C content
              }
            diff_content: |
              --- a/file.js
              +++ b/file.js
              @@ -1,7 +1,7 @@
               function partA() {
              -    // original A content
              -    // another line in A
              +    // updated A content
               }
               
               function partC() {
              -    // original C content
              +    // updated C content
               }
          expected:
            success: true
            content: |
              function partA() {
                  // updated A content
              }

              // User added this function, breaking the hunk
              function partB_user_added() {}

              // User also modified this part slightly
              function partC_modified_by_user() { // modified
                  // updated C content
              }
    patchStrategy: replace
  - type: write
    path: test/fixtures/standard-diff/failure.yml
    content: |-
      # Tests for failing applications of standard diffs
      apply_diff_tests:
        - name: fail-on-non-existent-content
          description: Should fail when the diff context does not match the original content
          input:
            original_content: |
              line1
              line2
              line3
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,3 +1,3 @@
               line1
              -nonexistent line
              +new line
               line3
          expected:
            success: false
            reason: "Could not apply modification"
        - name: fail-on-overlapping-hunks
          description: Should fail to apply diffs that contain overlapping hunks
          input:
            original_content: |
              line1
              line2
              line3
              line4
              line5
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,3 +1,3 @@
               line1
               line2
              -line3
              +modified3
              @@ -2,3 +2,2 @@
               line2
              -line3
              -line4
              +modified3and4
          expected:
            success: false
            reason: "Hunks overlap"
        - name: hunk-splitting-failure
          description: Should fail if a sub-hunk fails to apply after splitting
          input:
            original_content: |
              function partA() {
                  // some code A
              }
              function partB() {
                  // completely different code B
              }
            diff_content: |
              --- a/file.js
              +++ b/file.js
              @@ -1,5 +1,5 @@
               function partA() {
              -    // some code A
              +    // new code A
               }
               function partB() {
              -    // some code B
              +    // new code B
               }
          expected:
            success: false
            reason: "Could not apply modification"
    patchStrategy: replace
  - type: write
    path: test/fixtures/standard-diff/edge-cases.yml
    content: |-
      # Tests for edge cases
      apply_diff_tests:
        - name: pure-insertion-at-start
          description: Should correctly insert content at the beginning of a file
          input:
            original_content: |
              line 1
              line 2
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -0,0 +1,2 @@
              +new line 1
              +new line 2
          expected:
            success: true
            content: |
              new line 1
              new line 2
              line 1
              line 2

        - name: unicode-characters
          description: Should correctly handle files with unicode characters
          input:
            original_content: "你好世界"
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1 +1 @@
              -你好世界
              +こんにちは世界
          expected:
            success: true
            content: "こんにちは世界"

        - name: pure-insertion-after-line
          description: Should correctly apply a hunk that only contains additions after a specific line
          input:
            original_content: |
              line 1
              line 3
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,0 +2,1 @@
              +line 2
          expected:
            success: true
            content: |
              line 1
              line 2
              line 3

        - name: pure-deletion-hunk
          description: Should correctly apply a hunk that only contains deletions
          input:
            original_content: |
              line 1
              line 2 to delete
              line 3
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,3 +1,2 @@
               line 1
              -line 2 to delete
               line 3
          expected:
            success: true
            content: |
              line 1
              line 3

        - name: apply-to-empty-file
          description: Should correctly apply a diff to an empty file (file creation)
          input:
            original_content: ""
            diff_content: |
              --- /dev/null
              +++ b/file.txt
              @@ -0,0 +1,3 @@
              +Hello
              +World
              +!
          expected:
            success: true
            content: |
              Hello
              World
              !

        - name: delete-all-content
          description: Should correctly empty a file when the diff removes all lines
          input:
            original_content: |
              line 1
              line 2
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,2 +0,0 @@
              -line 1
              -line 2
          expected:
            success: true
            content: ""

        - name: modify-start-of-file
          description: Should correctly apply a hunk that modifies the beginning of the file
          input:
            original_content: |
              first line
              second line
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1,2 +1,2 @@
              -first line
              +modified first line
               second line
          expected:
            success: true
            content: |
              modified first line
              second line

        - name: add-to-file-without-trailing-newline
          description: Should correctly add content to a file that lacks a trailing newline
          input:
            original_content: "line 1"
            diff_content: |
              --- a/file.txt
              +++ b/file.txt
              @@ -1 +1,2 @@
               line 1
              +line 2
          expected:
            success: true
            content: |
              line 1
              line 2
    patchStrategy: replace
  - type: write
    path: test/fixtures/standard-diff/description.yml
    content: |-
      # Tests for the `getToolDescription` function
      tool_description_tests:
        - name: description-contains-key-elements
          description: Should generate a description that includes CWD and standard diff format markers
          input:
            cwd: "/mock/workspace"
          expected_to_contain:
            - "current working directory /mock/workspace"
            - "--- a/src/component.tsx"
            - "+++ b/src/component.tsx"
            - "@@ ... @@"
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/success.yml
    content: |-
      apply_diff_tests:
        - name: replace-exact-match
          description: Should replace content that is an exact match
          input:
            original_content: |
              function hello() {
                  console.log("hello")
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              function hello() {
                  console.log("hello")
              }
              =======
              function hello() {
                  console.log("hello world");
              }
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              function hello() {
                  console.log("hello world");
              }

        - name: multiple-blocks-in-one-call
          description: Should process multiple search/replace blocks in a single operation
          input:
            original_content: |
              const a = "apple";
              const b = "banana";
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              const a = "apple";
              =======
              const a = "apricot";
              >>>>>>> REPLACE
              <<<<<<< SEARCH
              const b = "banana";
              =======
              const b = "blueberry";
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              const a = "apricot";
              const b = "blueberry";

        - name: sequential-overlapping-replace
          description: Should handle sequential replacements where the second depends on the first
          input:
            original_content: |
              function one() {
                  return 1;
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              function one() {
                  return 1;
              }
              =======
              function two() {
                  return 2;
              }
              >>>>>>> REPLACE
              <<<<<<< SEARCH
              function two() {
              =======
              function two() { // Renamed
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              function two() { // Renamed
                  return 2;
              }

        - name: replace-with-regex-special-chars
          description: Should correctly replace content that contains special regex characters
          input:
            original_content: "const x = arr[0] + (y || 0);"
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              arr[0] + (y || 0)
              =======
              arr[0] * (y || 1)
              >>>>>>> REPLACE
          expected:
            success: true
            content: "const x = arr[0] * (y || 1);"
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/indentation.yml
    content: |-
      apply_diff_tests:
        - name: preserve-indentation-on-addition
          description: Should preserve original indentation when adding new lines
          input:
            original_content: |
              class Example {
                  getValue() {
                      return this.value
                  }
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
                  getValue() {
                      return this.value
                  }
              =======
                  getValue() {
                      // Add logging
                      console.log("Getting value");
                      return this.value;
                  }
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              class Example {
                  getValue() {
                      // Add logging
                      console.log("Getting value");
                      return this.value;
                  }
              }
        - name: indentation-agnostic-search-and-preserve
          description: Should find content regardless of its indentation and preserve it on replace
          input:
            original_content: |
                  function test() {
                      return true;
                  }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              function test() {
                  return true;
              }
              =======
              function test() {
                  return false;
              }
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
                  function test() {
                      return false;
                  }
        - name: respect-relative-indentation-in-replace
          description: Should respect the relative indentation inside the REPLACE block
          input:
            original_content: |
              class Test {
                  method() {
                      console.log("test");
                  }
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
                  method() {
                      console.log("test");
                  }
              =======
                  method() {
                      try {
                          if (true) {
                              console.log("test");
                          }
                      } catch (e) {
                          console.error(e);
                      }
                  }
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              class Test {
                  method() {
                      try {
                          if (true) {
                              console.log("test");
                          }
                      } catch (e) {
                          console.error(e);
                      }
                  }
              }
        - name: replace-with-complex-relative-indentation
          description: Should correctly re-indent a replacement block with multiple indentation levels
          input:
            original_content: |
              function outer() {
                  if (condition) {
                      process();
                  }
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              process();
              =======
              if (anotherCondition) {
                  process();
              } else {
                  fallback();
              }
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              function outer() {
                  if (condition) {
                      if (anotherCondition) {
                          process();
                      } else {
                          fallback();
                      }
                  }
              }
        - name: insertion-with-inferred-indentation
          description: Should insert code and correctly apply surrounding indentation
          input:
            original_content: |
              function outer() {
                  if (true) {
                      // marker
                  }
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              =======
              console.log("inserted");
              >>>>>>> REPLACE
            start_line: 3
          expected:
            success: true
            content: |
              function outer() {
                  if (true) {
                      console.log("inserted");
                      // marker
                  }
              }
        - name: insertion-at-end-of-block-with-inferred-indentation
          description: Should infer indentation from previous line when inserting before a closing brace
          input:
            original_content: |
              function myFunc() {
                  console.log("hello");
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              =======
              console.log("world");
              >>>>>>> REPLACE
            start_line: 3
          expected:
            success: true
            content: |
              function myFunc() {
                  console.log("hello");
                  console.log("world");
              }
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/fuzzy.yml
    content: |-
      apply_diff_tests:
        - name: fuzzy-match-on-minor-difference
          description: Should find and replace content that is slightly different from the search block
          input:
            original_content: |
              function calculate() {
                // A comment
                const result = 1 + 1;
                return result;
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
                // An old comment
                const result = 1 + 1;
              =======
                const result = 2 * 2; // updated logic
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              function calculate() {
                const result = 2 * 2; // updated logic
                return result;
              }
        - name: fuzzy-delete
          description: Should delete a block of code even with minor differences
          input:
            original_content: |
              function hello() {
                  // This is a very important comment
                  console.log("hello");
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
                  // This is an important comment
                  console.log("hello");
              =======
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              function hello() {
              }
        - name: fuzzy-match-accept-minor-string-literal-change
          description: Should accept a fuzzy match with a minor, non-semantic change in a string literal
          input:
            original_content: |
              logger.error("Failed to connect to database!"); // User added exclamation
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              logger.error("Failed to connect to database");
              =======
              Sentry.captureMessage("Failed to connect to database!");
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              Sentry.captureMessage("Failed to connect to database!"); // User added exclamation
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/failure.yml
    content: |-
      apply_diff_tests:
        - name: fail-on-no-match
          description: Should fail gracefully if the search content does not match
          input:
            original_content: |
              function hello() {
                  console.log("hello")
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              function hello() {
                  console.log("wrong")
              }
              =======
              function hello() {
                  console.log("hello world")
              }
              >>>>>>> REPLACE
          expected:
            success: false
            reason: "Search block not found"
        - name: fail-on-invalid-format
          description: Should fail gracefully if the diff format is invalid
          input:
            original_content: "function hello() {}"
            diff_content: "This is not a valid format"
          expected:
            success: false
            reason: "Invalid diff format"
        - name: insertion-fail-without-line-number
          description: Should fail an insertion if no start_line is provided
          input:
            original_content: "function test() {}"
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              =======
              console.log("test");
              >>>>>>> REPLACE
          expected:
            success: false
            reason: "Insertion requires a start_line"
        - name: fuzzy-match-rejection-on-string-literal-change
          description: Should reject a fuzzy match that changes the semantic meaning of a string literal
          input:
            original_content: |
              logger.error("Failed to connect to database");
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              logger.error("Failed to load configuration");
              =======
              Sentry.captureMessage("Failed to load configuration");
              >>>>>>> REPLACE
          expected:
            success: false
            reason: "Search block not found"
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/edge-cases.yml
    content: |-
      apply_diff_tests:
        - name: strip-line-numbers
          description: Should strip leading line numbers from search and replace blocks
          input:
            original_content: "    return true;"
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              2 |     return true;
              =======
              2 |     return false; // A comment
              >>>>>>> REPLACE
          expected:
            success: true
            content: "    return false; // A comment"
        - name: first-of-ambiguous-match-is-replaced
          description: Should replace the first occurrence of an ambiguous match when no line numbers are given
          input:
            original_content: |
              config.set("value", 1);
              // ... lots of code
              config.set("value", 1);
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              config.set("value", 1);
              =======
              config.set("value", 2);
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              config.set("value", 2);
              // ... lots of code
              config.set("value", 1);
        - name: replace-at-start-of-file
          description: Should correctly replace content at the very beginning of the file
          input:
            original_content: |
              // Header
              function start() {}
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              // Header
              =======
              // New Header
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              // New Header
              function start() {}
        - name: replace-at-end-of-file
          description: Should correctly replace content at the very end of the file
          input:
            original_content: |
              function start() {}
              // Footer
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              // Footer
              =======
              // New Footer
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              function start() {}
              // New Footer
        - name: replace-block-with-trailing-newline
          description: Should correctly handle a replace block that ends with a newline
          input:
            original_content: |
              const x = 1;
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              const x = 1;
              =======
              const y = 2;

              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              const y = 2;

        - name: remove-extra-blank-lines
          description: Should be able to search for and remove only whitespace
          input:
            original_content: |
              line 1


              line 2
            diff_content: |
              test.ts
              <<<<<<< SEARCH

              =======
              >>>>>>> REPLACE
          expected:
            success: true
            content: |
              line 1

              line 2
        - name: unicode-characters-replace
          description: Should correctly handle files with unicode characters in search and replace
          input:
            original_content: "const greeting = '你好世界';"
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              '你好世界'
              =======
              'こんにちは世界'
              >>>>>>> REPLACE
          expected:
            success: true
            content: "const greeting = 'こんにちは世界';"
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/insertion-deletion.yml
    content: |-
      apply_diff_tests:
        - name: insertion-with-start-line
          description: Should insert code at a specific line when the search block is empty
          input:
            original_content: |
              function test() {
                  const x = 1;
                  return x;
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              =======
                  console.log("Adding log");
              >>>>>>> REPLACE
            start_line: 2
            end_line: 2
          expected:
            success: true
            content: |
              function test() {
                  console.log("Adding log");
                  const x = 1;
                  return x;
              }
        - name: deletion
          description: Should delete code when the replace block is empty
          input:
            original_content: |

              function test() {
                  // Comment to remove
              }
            diff_content: |
              test.ts
              <<<<<<< SEARCH
                  // Comment to remove
              =======
              >>>>>>> REPLACE
          expected:
            success: true
            content: |

              function test() {
              }
        - name: empty-file-insertion
          description: Should insert content into an empty file without extra newlines
          input:
            original_content: ""
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              =======
              Hello, World!
              >>>>>>> REPLACE
            start_line: 1
          expected:
            success: true
            content: "Hello, World!"
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/line-numbers.yml
    content: |-
      apply_diff_tests:
        - name: constrained-search-target-specific-duplicate
          description: Should use line numbers to target a specific instance of duplicate code
          input:
            original_content: |
              // Instance 1
              processData();

              // Instance 2
              processData();
            diff_content: |
              test.ts
              <<<<<<< SEARCH
              processData();
              =======
              processData(config);
              >>>>>>> REPLACE
            start_line: 5
            end_line: 5
          expected:
            success: true
            content: |
              // Instance 1
              processData();

              // Instance 2
              processData(config);
    patchStrategy: replace
  - type: write
    path: test/fixtures/search-replace/description.yml
    content: |-
      # Tests for the `getToolDescription` function
      tool_description_tests:
        - name: description-contains-key-elements
          description: Should generate a description that includes the CWD and format requirements
          input:
            cwd: "/mock/workspace"
          expected_to_contain:
            - "current working directory /mock/workspace"
            - "<<<<<<< SEARCH"
            - "======="
            - ">>>>>>> REPLACE"
            - "start_line"
            - "end_line"
    patchStrategy: replace
  - type: write
    path: test/strategies/standard-diff.test.ts
    content: >-
      --- test/strategies/standard-diff.test.ts

      +++ test/strategies/standard-diff.test.ts

      @@ -28,11 +28,29 @@
         }[];
       }
       
      -// Load and parse the YAML fixture

      -const fixturePath = path.join(__dirname,
      "../fixtures/standard-diff.yml");

      -const fixtures = yaml.load(

      -  fs.readFileSync(fixturePath, "utf-8")

      -) as TestFixtures;

      +const loadFixturesFromDir = (dirPath: string): TestFixtures => {

      +  const allFixtures: TestFixtures = {

      +    tool_description_tests: [],

      +    apply_diff_tests: [],

      +  };

      +  const files = fs.readdirSync(dirPath);

      +  for (const file of files) {

      +    if (path.extname(file) === ".yml" || path.extname(file) === ".yaml")
      {

      +      const filePath = path.join(dirPath, file);

      +      const fixture = yaml.load(

      +        fs.readFileSync(filePath, "utf-8")

      +      ) as Partial<TestFixtures>;

      +      if (fixture.tool_description_tests) {

      +       
      allFixtures.tool_description_tests.push(...fixture.tool_description_tests);

      +      }

      +      if (fixture.apply_diff_tests) {

      +        allFixtures.apply_diff_tests.push(...fixture.apply_diff_tests);

      +      }

      +    }

      +  }

      +  return allFixtures;

      +};

      +const fixturePath = path.join(__dirname, "../fixtures/standard-diff");

      +const fixtures = loadFixturesFromDir(fixturePath);
       
       // --- Test Suite ---
    patchStrategy: new-unified
  - type: write
    path: test/strategies/search-replace.test.ts
    content: >-
      --- test/strategies/search-replace.test.ts

      +++ test/strategies/search-replace.test.ts

      @@ -29,11 +29,29 @@
         }[];
       }
       
      -// Load and parse the YAML fixture

      -const fixturePath = path.join(__dirname,
      "../fixtures/search-replace.yml");

      -const fixtures = yaml.load(

      -  fs.readFileSync(fixturePath, "utf-8")

      -) as TestFixtures;

      +const loadFixturesFromDir = (dirPath: string): TestFixtures => {

      +  const allFixtures: TestFixtures = {

      +    tool_description_tests: [],

      +    apply_diff_tests: [],

      +  };

      +  const files = fs.readdirSync(dirPath);

      +  for (const file of files) {

      +    if (path.extname(file) === ".yml" || path.extname(file) === ".yaml")
      {

      +      const filePath = path.join(dirPath, file);

      +      const fixture = yaml.load(

      +        fs.readFileSync(filePath, "utf-8")

      +      ) as Partial<TestFixtures>;

      +      if (fixture.tool_description_tests) {

      +       
      allFixtures.tool_description_tests.push(...fixture.tool_description_tests);

      +      }

      +      if (fixture.apply_diff_tests) {

      +        allFixtures.apply_diff_tests.push(...fixture.apply_diff_tests);

      +      }

      +    }

      +  }

      +  return allFixtures;

      +};

      +const fixturePath = path.join(__dirname, "../fixtures/search-replace");

      +const fixtures = loadFixturesFromDir(fixturePath);
       
       // --- Test Suite ---
    patchStrategy: new-unified
  - type: write
    path: src/strategies/search-replace.ts
    content: >-
      --- src/strategies/search-replace.ts

      +++ src/strategies/search-replace.ts

      @@ -223,12 +223,23 @@
             const insertionIndex = Math.max(0, options.start_line - 1);
       
             // Infer indentation from the insertion line or surrounding lines
             let indent = "";
             if (insertionIndex < lines.length) {
      -        indent = lines[insertionIndex].match(/^[ \t]*/)?.[0] || "";

      +        const currentLineIndent = lines[insertionIndex].match(/^[
      \t]*/)?.[0] || "";

      +        if (insertionIndex > 0) {

      +          const prevLineIndent = lines[insertionIndex - 1].match(/^[
      \t]*/)?.[0] || "";

      +          // If current line is an outdent (like a closing brace), use
      previous line's indent

      +          if (prevLineIndent.length > currentLineIndent.length &&
      lines[insertionIndex].trim().length > 0) {

      +            indent = prevLineIndent;

      +          } else {

      +            indent = currentLineIndent;

      +          }

      +        } else {

      +          indent = currentLineIndent;

      +        }
             } else if (lines.length > 0) {
               // If inserting at the very end, use indent of last line
               indent = lines[lines.length - 1].match(/^[ \t]*/)?.[0] || "";
             }
       
             const replaceLines = block.replace.split('\n');
    patchStrategy: new-unified
snapshot:
  test/fixtures/standard-diff/success.yml: null
  test/fixtures/standard-diff/fuzzy.yml: null
  test/fixtures/standard-diff/failure.yml: null
  test/fixtures/standard-diff/edge-cases.yml: null
  test/fixtures/standard-diff/description.yml: null
  test/fixtures/search-replace/success.yml: null
  test/fixtures/search-replace/indentation.yml: null
  test/fixtures/search-replace/fuzzy.yml: null
  test/fixtures/search-replace/failure.yml: null
  test/fixtures/search-replace/edge-cases.yml: null
  test/fixtures/search-replace/insertion-deletion.yml: null
  test/fixtures/search-replace/line-numbers.yml: null
  test/fixtures/search-replace/description.yml: null
  test/fixtures/search-replace.yml: |
    # Tests for the `getToolDescription` function
    tool_description_tests:
      - name: description-contains-key-elements
        description: Should generate a description that includes the CWD and format requirements
        input:
          cwd: "/mock/workspace"
        expected_to_contain:
          - "current working directory /mock/workspace"
          - "<<<<<<< SEARCH"
          - "======="
          - ">>>>>>> REPLACE"
          - "start_line"
          - "end_line"

    # Tests for the `applyDiff` function
    apply_diff_tests:
      - name: replace-exact-match
        description: Should replace content that is an exact match
        input:
          original_content: |
            function hello() {
                console.log("hello")
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function hello() {
                console.log("hello")
            }
            =======
            function hello() {
                console.log("hello world");
            }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function hello() {
                console.log("hello world");
            }

      - name: preserve-indentation-on-addition
        description: Should preserve original indentation when adding new lines
        input:
          original_content: |
            class Example {
                getValue() {
                    return this.value
                }
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                getValue() {
                    return this.value
                }
            =======
                getValue() {
                    // Add logging
                    console.log("Getting value");
                    return this.value;
                }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            class Example {
                getValue() {
                    // Add logging
                    console.log("Getting value");
                    return this.value;
                }
            }

      - name: fuzzy-match-on-minor-difference
        description: Should find and replace content that is slightly different from the search block
        input:
          original_content: |
            function calculate() {
              // A comment
              const result = 1 + 1;
              return result;
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
              // An old comment
              const result = 1 + 1;
            =======
              const result = 2 * 2; // updated logic
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function calculate() {
              const result = 2 * 2; // updated logic
              return result;
            }

      - name: fail-on-no-match
        description: Should fail gracefully if the search content does not match
        input:
          original_content: |
            function hello() {
                console.log("hello")
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function hello() {
                console.log("wrong")
            }
            =======
            function hello() {
                console.log("hello world")
            }
            >>>>>>> REPLACE
        expected:
          success: false
          reason: "Search block not found"

      - name: indentation-agnostic-search-and-preserve
        description: Should find content regardless of its indentation and preserve it on replace
        input:
          original_content: |
                function test() {
                    return true;
                }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function test() {
                return true;
            }
            =======
            function test() {
                return false;
            }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
                function test() {
                    return false;
                }

      - name: respect-relative-indentation-in-replace
        description: Should respect the relative indentation inside the REPLACE block
        input:
          original_content: |
            class Test {
                method() {
                    console.log("test");
                }
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                method() {
                    console.log("test");
                }
            =======
                method() {
                    try {
                        if (true) {
                            console.log("test");
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            class Test {
                method() {
                    try {
                        if (true) {
                            console.log("test");
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            }

      - name: fail-on-invalid-format
        description: Should fail gracefully if the diff format is invalid
        input:
          original_content: "function hello() {}"
          diff_content: "This is not a valid format"
        expected:
          success: false
          reason: "Invalid diff format"

      - name: strip-line-numbers
        description: Should strip leading line numbers from search and replace blocks
        input:
          original_content: "    return true;"
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            2 |     return true;
            =======
            2 |     return false; // A comment
            >>>>>>> REPLACE
        expected:
          success: true
          content: "    return false; // A comment"

      - name: insertion-with-start-line
        description: Should insert code at a specific line when the search block is empty
        input:
          original_content: |
            function test() {
                const x = 1;
                return x;
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            =======
                console.log("Adding log");
            >>>>>>> REPLACE
          start_line: 2
          end_line: 2
        expected:
          success: true
          content: |
            function test() {
                console.log("Adding log");
                const x = 1;
                return x;
            }

      - name: insertion-fail-without-line-number
        description: Should fail an insertion if no start_line is provided
        input:
          original_content: "function test() {}"
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            =======
            console.log("test");
            >>>>>>> REPLACE
        expected:
          success: false
          reason: "Insertion requires a start_line"

      - name: deletion
        description: Should delete code when the replace block is empty
        input:
          original_content: |

            function test() {
                // Comment to remove
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                // Comment to remove
            =======
            >>>>>>> REPLACE
        expected:
          success: true
          content: |

            function test() {
            }

      - name: constrained-search-target-specific-duplicate
        description: Should use line numbers to target a specific instance of duplicate code
        input:
          original_content: |
            // Instance 1
            processData();

            // Instance 2
            processData();
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            processData();
            =======
            processData(config);
            >>>>>>> REPLACE
          start_line: 5
          end_line: 5
        expected:
          success: true
          content: |
            // Instance 1
            processData();

            // Instance 2
            processData(config);

      - name: multiple-blocks-in-one-call
        description: Should process multiple search/replace blocks in a single operation
        input:
          original_content: |
            const a = "apple";
            const b = "banana";
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            const a = "apple";
            =======
            const a = "apricot";
            >>>>>>> REPLACE
            <<<<<<< SEARCH
            const b = "banana";
            =======
            const b = "blueberry";
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            const a = "apricot";
            const b = "blueberry";

      - name: fuzzy-match-rejection-on-string-literal-change
        description: Should reject a fuzzy match that changes the semantic meaning of a string literal
        input:
          original_content: |
            logger.error("Failed to connect to database");
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            logger.error("Failed to load configuration");
            =======
            Sentry.captureMessage("Failed to load configuration");
            >>>>>>> REPLACE
        expected:
          success: false
          reason: "Search block not found"

      - name: replace-with-complex-relative-indentation
        description: Should correctly re-indent a replacement block with multiple indentation levels
        input:
          original_content: |
            function outer() {
                if (condition) {
                    process();
                }
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            process();
            =======
            if (anotherCondition) {
                process();
            } else {
                fallback();
            }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function outer() {
                if (condition) {
                    if (anotherCondition) {
                        process();
                    } else {
                        fallback();
                    }
                }
            }

      - name: empty-file-insertion
        description: Should insert content into an empty file without extra newlines
        input:
          original_content: ""
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            =======
            Hello, World!
            >>>>>>> REPLACE
          start_line: 1
        expected:
          success: true
          content: "Hello, World!"

      - name: first-of-ambiguous-match-is-replaced
        description: Should replace the first occurrence of an ambiguous match when no line numbers are given
        input:
          original_content: |
            config.set("value", 1);
            // ... lots of code
            config.set("value", 1);
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            config.set("value", 1);
            =======
            config.set("value", 2);
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            config.set("value", 2);
            // ... lots of code
            config.set("value", 1);

      - name: replace-at-start-of-file
        description: Should correctly replace content at the very beginning of the file
        input:
          original_content: |
            // Header
            function start() {}
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            // Header
            =======
            // New Header
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            // New Header
            function start() {}

      - name: replace-at-end-of-file
        description: Should correctly replace content at the very end of the file
        input:
          original_content: |
            function start() {}
            // Footer
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            // Footer
            =======
            // New Footer
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function start() {}
            // New Footer

      - name: sequential-overlapping-replace
        description: Should handle sequential replacements where the second depends on the first
        input:
          original_content: |
            function one() {
                return 1;
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function one() {
                return 1;
            }
            =======
            function two() {
                return 2;
            }
            >>>>>>> REPLACE
            <<<<<<< SEARCH
            function two() {
            =======
            function two() { // Renamed
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function two() { // Renamed
                return 2;
            }

      - name: insertion-with-inferred-indentation
        description: Should insert code and correctly apply surrounding indentation
        input:
          original_content: |
            function outer() {
                if (true) {
                    // marker
                }
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            =======
            console.log("inserted");
            >>>>>>> REPLACE
          start_line: 3
        expected:
          success: true
          content: |
            function outer() {
                if (true) {
                    console.log("inserted");
                    // marker
                }
            }

      - name: fuzzy-delete
        description: Should delete a block of code even with minor differences
        input:
          original_content: |
            function hello() {
                // This is a very important comment
                console.log("hello");
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                // This is an important comment
                console.log("hello");
            =======
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function hello() {
            }

      - name: replace-block-with-trailing-newline
        description: Should correctly handle a replace block that ends with a newline
        input:
          original_content: |
            const x = 1;
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            const x = 1;
            =======
            const y = 2;

            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            const y = 2;

      - name: remove-extra-blank-lines
        description: Should be able to search for and remove only whitespace
        input:
          original_content: |
            line 1


            line 2
          diff_content: |
            test.ts
            <<<<<<< SEARCH

            =======
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            line 1

            line 2

      - name: replace-with-regex-special-chars
        description: Should correctly replace content that contains special regex characters
        input:
          original_content: "const x = arr[0] + (y || 0);"
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            arr[0] + (y || 0)
            =======
            arr[0] * (y || 1)
            >>>>>>> REPLACE
        expected:
          success: true
          content: "const x = arr[0] * (y || 1);"

      - name: unicode-characters-replace
        description: Should correctly handle files with unicode characters in search and replace
        input:
          original_content: "const greeting = '你好世界';"
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            '你好世界'
            =======
            'こんにちは世界'
            >>>>>>> REPLACE
        expected:
          success: true
          content: "const greeting = 'こんにちは世界';"

      - name: fuzzy-match-accept-minor-string-literal-change
        description: Should accept a fuzzy match with a minor, non-semantic change in a string literal
        input:
          original_content: |
            logger.error("Failed to connect to database!"); // User added exclamation
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            logger.error("Failed to connect to database");
            =======
            Sentry.captureMessage("Failed to connect to database!");
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            Sentry.captureMessage("Failed to connect to database!"); // User added exclamation
  test/fixtures/standard-diff.yml: |-
    # Tests for the `getToolDescription` function
    tool_description_tests:
      - name: description-contains-key-elements
        description: Should generate a description that includes CWD and standard diff format markers
        input:
          cwd: "/mock/workspace"
        expected_to_contain:
          - "current working directory /mock/workspace"
          - "--- a/src/component.tsx"
          - "+++ b/src/component.tsx"
          - "@@ ... @@"

    # Tests for the `applyDiff` function
    apply_diff_tests:
      - name: simple-modification
        description: Should apply a simple modification, addition, and deletion correctly
        input:
          original_content: |
            line1
            line2
            line3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,4 @@
             line1
            +new line
             line2
            -line3
            +modified line3
        expected:
          success: true
          content: |
            line1
            new line
            line2
            modified line3

      - name: multiple-hunks
        description: Should correctly apply a diff with multiple, non-contiguous hunks
        input:
          original_content: |
            line1
            line2
            line3
            line4
            line5
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,2 +1,2 @@
             line1
            -line2
            +modified line2
            @@ -4,2 +4,2 @@
             line4
            -line5
            +modified line5
        expected:
          success: true
          content: |
            line1
            modified line2
            line3
            line4
            modified line5

      - name: correct-modification-with-similar-code
        description: Should correctly modify the right section when similar code exists elsewhere
        input:
          original_content: |
            function add(a, b) {
              return a + b;
            }

            function multiply(a, b) {
              return a + b;  // Bug here
            }
          diff_content: |
            --- a/math.js
            +++ b/math.js
            @@ -5,3 +5,3 @@
             function multiply(a, b) {
            -  return a + b;  // Bug here
            +  return a * b;
             }
        expected:
          success: true
          content: |
            function add(a, b) {
              return a + b;
            }

            function multiply(a, b) {
              return a * b;
            }

      - name: handle-indentation-changes
        description: Should correctly handle changes involving different types of indentation
        input:
          original_content: |
            function example() {
              let a = 1;
                let b = 2;
            }
          diff_content: |
            --- a/file.js
            +++ b/file.js
            @@ -1,4 +1,5 @@
             function example() {
               let a = 1;
            +  // new line
                 let b = 2;
             }
        expected:
          success: true
          content: |
            function example() {
              let a = 1;
              // new line
                let b = 2;
            }

      - name: handle-empty-lines-modification
        description: Should correctly apply changes that involve empty lines
        input:
          original_content: |
            line1

            line3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,3 @@
             line1
             
            -line3
            +line3-modified
        expected:
          success: true
          content: |
            line1

            line3-modified
      
      - name: fuzzy-match-with-drifted-context
        description: Should apply a hunk correctly even if the context has minor changes
        input:
          original_content: |
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.20;

            contract SimpleStore {
                uint256 private _value; // The value stored

                function setValue(uint256 value) public {
                    _value = value;
                }
            }
          diff_content: |
            --- a/SimpleStore.sol
            +++ b/SimpleStore.sol
            @@ -3,6 +3,10 @@
             
             contract SimpleStore {
                 uint256 private _value; // The value stored
            +
            +    function getValue() public view returns (uint256) {
            +        return _value;
            +    }
             
                 function setValue(uint256 value) public {
                     _value = value;
        expected:
          success: true
          content: |
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.20;

            contract SimpleStore {
                uint256 private _value; // The value stored

                function getValue() public view returns (uint256) {
                    return _value;
                }

                function setValue(uint256 value) public {
                    _value = value;
                }
            }

      - name: fallback-hunk-splitting-on-failure
        description: Should split a failing hunk into smaller parts and apply them individually
        input:
          original_content: |
            import { readFile } from 'fs';
            import { Logger } from './logger';

            const logger = new Logger();

            async function processFile(filePath: string) {
              try {
                const data = await readFile(filePath, 'utf8');
                logger.info('File read successfully');
                return data;
              } catch (error) {
                logger.error('Failed to read file:', error);
                throw error;
              }
            }
          diff_content: |
            --- a/file.ts
            +++ b/file.ts
            @@ -1,13 +1,13 @@
             import { readFile } from 'fs';
            -import { Logger } from './logger';
            +import { Logger } from './utils/logger';
             
             const logger = new Logger(); // This context line is correct
             
             async function processFile(filePath: string) { // This context line is also correct
               try {
                 const data = await readFile(filePath, 'utf8');
            -    logger.info('File read successfully');
            +    logger.info(`File ${filePath} read successfully`);
                 return data;
               } catch (error) {
                 logger.error('Failed to read file:', error);
                 throw error;
               }
             }
        expected:
          success: true
          content: |
            import { readFile } from 'fs';
            import { Logger } from './utils/logger';

            const logger = new Logger();

            async function processFile(filePath: string) {
              try {
                const data = await readFile(filePath, 'utf8');
                logger.info(`File ${filePath} read successfully`);
                return data;
              } catch (error) {
                logger.error('Failed to read file:', error);
                throw error;
              }
            }

      - name: fail-on-non-existent-content
        description: Should fail when the diff context does not match the original content
        input:
          original_content: |
            line1
            line2
            line3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,3 @@
             line1
            -nonexistent line
            +new line
             line3
        expected:
          success: false
          reason: "Could not apply modification"

      - name: pure-insertion-at-start
        description: Should correctly insert content at the beginning of a file
        input:
          original_content: |
            line 1
            line 2
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -0,0 +1,2 @@
            +new line 1
            +new line 2
        expected:
          success: true
          content: |
            new line 1
            new line 2
            line 1
            line 2

      - name: unicode-characters
        description: Should correctly handle files with unicode characters
        input:
          original_content: "你好世界"
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1 +1 @@
            -你好世界
            +こんにちは世界
        expected:
          success: true
          content: "こんにちは世界"

      - name: pure-insertion-after-line
        description: Should correctly apply a hunk that only contains additions after a specific line
        input:
          original_content: |
            line 1
            line 3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,0 +2,1 @@
            +line 2
        expected:
          success: true
          content: |
            line 1
            line 2
            line 3

      - name: pure-deletion-hunk
        description: Should correctly apply a hunk that only contains deletions
        input:
          original_content: |
            line 1
            line 2 to delete
            line 3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,2 @@
             line 1
            -line 2 to delete
             line 3
        expected:
          success: true
          content: |
            line 1
            line 3

      - name: apply-to-empty-file
        description: Should correctly apply a diff to an empty file (file creation)
        input:
          original_content: ""
          diff_content: |
            --- /dev/null
            +++ b/file.txt
            @@ -0,0 +1,3 @@
            +Hello
            +World
            +!
        expected:
          success: true
          content: |
            Hello
            World
            !

      - name: delete-all-content
        description: Should correctly empty a file when the diff removes all lines
        input:
          original_content: |
            line 1
            line 2
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,2 +0,0 @@
            -line 1
            -line 2
        expected:
          success: true
          content: ""

      - name: modify-start-of-file
        description: Should correctly apply a hunk that modifies the beginning of the file
        input:
          original_content: |
            first line
            second line
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,2 +1,2 @@
            -first line
            +modified first line
             second line
        expected:
          success: true
          content: |
            modified first line
            second line

      - name: add-to-file-without-trailing-newline
        description: Should correctly add content to a file that lacks a trailing newline
        input:
          original_content: "line 1"
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1 +1,2 @@
             line 1
            +line 2
        expected:
          success: true
          content: |
            line 1
            line 2

      - name: fail-on-overlapping-hunks
        description: Should fail to apply diffs that contain overlapping hunks
        input:
          original_content: |
            line1
            line2
            line3
            line4
            line5
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,3 @@
             line1
             line2
            -line3
            +modified3
            @@ -2,3 +2,2 @@
             line2
            -line3
            -line4
            +modified3and4
        expected:
          success: false
          reason: "Hunks overlap"

      - name: fuzzy-match-with-actual-drift
        description: Should apply a hunk using fuzzy matching when context has drifted due to new comments
        input:
          original_content: |
            // User added a comment here
            class MyComponent extends React.Component {
              render() {
                const { value } = this.props;
                // And another comment here
                return <div>{value}</div>;
              }
            }
          diff_content: |
            --- a/component.jsx
            +++ b/component.jsx
            @@ -2,5 +2,5 @@
             class MyComponent extends React.Component {
               render() {
                 const { value } = this.props;
            -    return <div>{value}</div>;
            +    return <p>{value}</p>;
               }
             }
        expected:
          success: true
          content: |
            // User added a comment here
            class MyComponent extends React.Component {
              render() {
                const { value } = this.props;
                // And another comment here
                return <p>{value}</p>;
              }
            }

      - name: hunk-splitting-with-intermediate-user-edit
        description: Should succeed by splitting a hunk when a user edit breaks its contiguity
        input:
          original_content: |
            function setup() {
                console.log("Initializing part 1...");
                // init
            }

            // User added a new function here, breaking the hunk's contiguity
            function helper() {
                return true;
            }

            function tearDown() {
                console.log("Tearing down part 3...");
                // teardown
            }
          diff_content: |
            --- a/file.js
            +++ b/file.js
            @@ -1,8 +1,8 @@
             function setup() {
            -    console.log("Initializing part 1...");
            -    // init
            +    console.log("Initializing part 1... DONE");
            +    // initialize
             }
             
             function tearDown() {
            -    console.log("Tearing down part 3...");
            -    // teardown
            +    console.log("Tearing down part 3... DONE");
            +    // deinitialize
             }
        expected:
          success: true
          content: |
            function setup() {
                console.log("Initializing part 1... DONE");
                // initialize
            }

            // User added a new function here, breaking the hunk's contiguity
            function helper() {
                return true;
            }

            function tearDown() {
                console.log("Tearing down part 3... DONE");
                // deinitialize
            }

      - name: hunk-splitting-failure
        description: Should fail if a sub-hunk fails to apply after splitting
        input:
          original_content: |
            function partA() {
                // some code A
            }
            function partB() {
                // completely different code B
            }
          diff_content: |
            --- a/file.js
            +++ b/file.js
            @@ -1,5 +1,5 @@
             function partA() {
            -    // some code A
            +    // new code A
             }
             function partB() {
            -    // some code B
            +    // new code B
             }
        expected:
          success: false
          reason: "Could not apply modification"
  test/strategies/standard-diff.test.ts: |-
    import { describe, it, expect } from "bun:test";
    import fs from "fs";
    import path from "path";
    import yaml from "js-yaml";

    // --- Mocked/Assumed Imports ---
    // These functions would be imported from your actual source code.
    // We are assuming their existence and signatures for this test file.
    import {
      applyDiff,
      getToolDescription,
    } from "../../src/strategies/standard-diff";
    // -----------------------------

    // Define the structure of the test fixture files
    interface TestFixtures {
      tool_description_tests: {
        name: string;
        description: string;
        input: { cwd: string };
        expected_to_contain: string[];
      }[];
      apply_diff_tests: {
        name: string;
        description: string;
        input: {
          original_content: string;
          diff_content: string;
        };
        expected: {
          success: boolean;
          content?: string;
          reason?: string;
        };
      }[];
    }

    // Load and parse the YAML fixture
    const fixturePath = path.join(__dirname, "../fixtures/standard-diff.yml");
    const fixtures = yaml.load(
      fs.readFileSync(fixturePath, "utf-8")
    ) as TestFixtures;

    // --- Test Suite ---

    describe("Standard Diff Strategy", () => {
      describe("getToolDescription()", () => {
        fixtures.tool_description_tests.forEach((testCase) => {
          it(testCase.description, () => {
            const description = getToolDescription(testCase.input.cwd);
            for (const expected of testCase.expected_to_contain) {
              expect(description).toInclude(expected);
            }
          });
        });
      });

      describe("applyDiff()", () => {
        fixtures.apply_diff_tests.forEach((testCase) => {
          it(testCase.description, () => {
            const result = applyDiff(
              testCase.input.original_content,
              testCase.input.diff_content
            );

            expect(result.success).toBe(testCase.expected.success);

            if (testCase.expected.success) {
              if (result.success) {
                expect(result.content).toBe(testCase.expected.content ?? "");
              } else {
                throw new Error("Expected success but got failure");
              }
            } else {
              if (!result.success) {
                if (testCase.expected.reason) {
                  expect(result.error.message).toInclude(testCase.expected.reason);
                }
              } else {
                throw new Error("Expected failure but got success");
              }
            }
          });
        });
      });
    });
  test/strategies/search-replace.test.ts: |-
    import { describe, it, expect } from "bun:test";
    import fs from "fs";
    import path from "path";
    import yaml from "js-yaml";

    // --- Mocked/Assumed Imports ---
    // These functions would be imported from your actual source code.
    // We are assuming their existence and signatures for this test file.
    import {
      applyDiff,
      getToolDescription,
    } from "../../src/strategies/search-replace";
    // -----------------------------

    // Define the structure of the test fixture files
    interface TestFixtures {
      tool_description_tests: {
        name: string;
        description: string;
        input: { cwd: string };
        expected_to_contain: string[];
      }[];
      apply_diff_tests: {
        name: string;
        description: string;
        input: {
          original_content: string;
          diff_content: string;
          start_line?: number;
          end_line?: number;
        };
        expected: {
          success: boolean;
          content?: string;
          reason?: string;
        };
      }[];
    }

    // Load and parse the YAML fixture
    const fixturePath = path.join(__dirname, "../fixtures/search-replace.yml");
    const fixtures = yaml.load(
      fs.readFileSync(fixturePath, "utf-8")
    ) as TestFixtures;

    // --- Test Suite ---

    describe("Search/Replace Strategy", () => {
      describe("getToolDescription()", () => {
        fixtures.tool_description_tests.forEach((testCase) => {
          it(testCase.description, () => {
            const description = getToolDescription(testCase.input.cwd);
            for (const expected of testCase.expected_to_contain) {
              expect(description).toInclude(expected);
            }
          });
        });
      });

      describe("applyDiff()", () => {
        fixtures.apply_diff_tests.forEach((testCase) => {
          it(testCase.description, () => {
            const result = applyDiff(
              testCase.input.original_content,
              testCase.input.diff_content,
              {
                start_line: testCase.input.start_line,
                end_line: testCase.input.end_line,
              }
            );

            expect(result.success).toBe(testCase.expected.success);

            if (testCase.expected.success) {
              if (result.success) {
                expect(result.content).toBe(testCase.expected.content ?? "");
              } else {
                throw new Error("Expected success but got failure");
              }
            } else {
              if (!result.success) {
                if (testCase.expected.reason) {
                  expect(result.error.message).toInclude(testCase.expected.reason);
                }
              } else {
                throw new Error("Expected failure but got success");
              }
            }
          });
        });
      });
    });
  src/strategies/search-replace.ts: >-
    import { ERROR_CODES } from "../constants";

    import type { ApplyDiffResult } from "../types";

    import { createErrorResult } from "../utils/error";

    import { getCommonIndent, levenshtein, dedent } from "../utils/string";


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Search and Replace

    Applies a targeted code change to a single file using a search-and-replace
    format. This is ideal for precise modifications, insertions, or deletions of
    specific code blocks. It supports fuzzy matching and multiple replacements
    in a single call.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing one or more search and replace blocks.
      :start_line: (optional) The line number in the original file where the search block is expected to start. Use this to resolve ambiguity when the same code appears multiple times. Required for insertions.
      :end_line: (optional) The line number in the original file where the search block is expected to end.

    Format Requirements:

    The \`diff_content\` must follow this structure. You can include multiple
    blocks.


    <file_path_ignored_but_useful_for_context>

    <<<<<<< SEARCH

    [content to find and replace]

    =======

    [new content to insert]

    >>>>>>> REPLACE


    Special Cases:

    - To INSERT code, leave the SEARCH block empty and provide a \`start_line\`.
    The new code will be inserted before that line.

    - To DELETE code, leave the REPLACE block empty.


    Examples:


    1. Fuzzy Replace (will match even if comments are slightly different):

    <apply_diff file_path="src/utils.ts">
      src/utils.ts
      <<<<<<< SEARCH
      // old function
      function oldFunction() {
        return 1;
      }
      =======
      // new, improved function
      function newFunction() {
        return 2;
      }
      >>>>>>> REPLACE
    </apply_diff>


    2. Insertion (note the empty SEARCH block and \`start_line\`):

    <apply_diff file_path="src/app.ts" start_line="5">
      src/app.ts
      <<<<<<< SEARCH
      =======
      // Add a new configuration setting
      const newConfig = initializeNewDependency();
      >>>>>>> REPLACE
    </apply_diff>`;

    };


    const stripLineNumbers = (text: string): string => {
      const lines = text.split("\n");
      const allLinesNumbered = lines
        .filter((line) => line.trim() !== "")
        .every((line) => /^\s*\d+\s*\|/.test(line));
      if (!allLinesNumbered) return text;
      return lines.map((line) => line.replace(/^\s*\d+\s*\|\s?/, "")).join("\n");
    };


    const cleanBlock = (block: string) =>
      block.replace(/^\r?\n/, "").replace(/\r?\n?$/, "");

    type SearchReplaceBlock = { search: string; replace: string };


    const parseDiff = (diffContent: string): SearchReplaceBlock[] | null => {
      const blocks: SearchReplaceBlock[] = [];
      const searchMarker = /^\s*<<<<<<< SEARCH\s*$/m;
      const replaceMarker = /^\s*>>>>>>> REPLACE\s*$/m;

      let content = diffContent;
      const firstLineEnd = content.indexOf("\n");
      if (firstLineEnd !== -1 && !content.substring(0, firstLineEnd).includes("<<<<<<<")) {
        content = content.substring(firstLineEnd + 1);
      }

      while (searchMarker.test(content)) {
        const searchStart = content.search(searchMarker);
        const replaceEndMatch = content.match(replaceMarker);
        if (!replaceEndMatch || typeof replaceEndMatch.index === "undefined") break;
        
        const replaceEnd = replaceEndMatch.index + replaceEndMatch[0].length;
        const blockContent = content.substring(searchStart, replaceEnd);
        
        const parts = blockContent.split(
          /^\s*<<<<<<< SEARCH\s*$|^\s*=======*\s*$|^\s*>>>>>>> REPLACE\s*$/m
        );
        
        if (parts.length >= 4) {
          blocks.push({
            search: stripLineNumbers(cleanBlock(parts[1])),
            replace: stripLineNumbers(cleanBlock(parts[2])),
          });
        }
        content = content.substring(replaceEnd);
      }

      return blocks.length > 0 ? blocks : null;
    };


    const findBestMatch = (
      sourceLines: readonly string[],
      searchLines: readonly string[],
      startLine: number,
      endLine: number
    ): { index: number; distance: number } | null => {
      if (searchLines.length === 0) return null;

      let bestMatchIndex = -1;
      let minDistance = Infinity;
      const searchText = searchLines.join("\n");
      const dedentedSearchText = dedent(searchText);
      const maxDistanceThreshold = Math.max(
        10, // a minimum for short blocks or substring-like matches
        Math.floor(dedentedSearchText.length * 0.5) // 50% tolerance for fuzzy matching
      );

      const searchStart = startLine - 1;
      const searchEnd = endLine ?? sourceLines.length;

      for (let i = searchStart; i <= searchEnd - searchLines.length; i++) {
        const slice = sourceLines.slice(i, i + searchLines.length);
        const sliceText = slice.join("\n");
        const dedentedSliceText = dedent(sliceText);
        const distance = levenshtein(dedentedSearchText, dedentedSliceText);
        if (distance < minDistance) {
          minDistance = distance;
          bestMatchIndex = i;
        }
        if (distance === 0) break;
      }
      if (bestMatchIndex === -1 || minDistance > maxDistanceThreshold) {
        return null;
      }
      
      // Additional check: if a change was detected, reject if it looks like a semantic change inside a string literal
      if (minDistance > 0) {
        const slice = sourceLines.slice(bestMatchIndex, bestMatchIndex + searchLines.length);
        const sliceText = slice.join("\n");
        const dedentedSliceText = dedent(sliceText);
        
        // Check if both contain string literals and they're different
        const searchHasString = /["'].*["']/.test(dedentedSearchText);
        const sliceHasString = /["'].*["']/.test(dedentedSliceText);
        
        if (searchHasString && sliceHasString) {
          // Extract the string content to see if it's a semantic change
          const searchStringMatch = dedentedSearchText.match(/["'](.*?)["']/);
          const sliceStringMatch = dedentedSliceText.match(/["'](.*?)["']/);
          
          if (searchStringMatch && sliceStringMatch) {
            const searchString = searchStringMatch[1];
            const sliceString = sliceStringMatch[1];

            if (levenshtein(searchString, sliceString) > searchString.length * 0.5) {
              return null;
            }
          }
        }
      }
      return { index: bestMatchIndex, distance: minDistance };
    };


    export const applyDiff = (
      original_content: string,
      diff_content: string,
      options: { start_line?: number; end_line?: number } = {}
    ): ApplyDiffResult => {
      const blocks = parseDiff(diff_content);
      if (!blocks) {
        return createErrorResult(
          ERROR_CODES.INVALID_DIFF_FORMAT,
          "Invalid diff format. Could not parse any '<<<<<<< SEARCH'...'>>>>>>> REPLACE' blocks."
        );
      }

      let currentContent = original_content;

      for (const block of blocks) {
        if (block.search === "") {
          // Pure insertion
          if (typeof options.start_line !== "number") {
            return createErrorResult(
              ERROR_CODES.INSERTION_REQUIRES_LINE_NUMBER,
              "Insertion requires a start_line. A SEARCH block was empty, but no start_line was provided."
            );
          }
          // Special case for inserting into an empty file
          if (currentContent === "") {
            currentContent = block.replace;
            continue;
          }

          const lines = currentContent.split("\n");
          const insertionIndex = Math.max(0, options.start_line - 1);

          // Infer indentation from the insertion line or surrounding lines
          let indent = "";
          if (insertionIndex < lines.length) {
            indent = lines[insertionIndex].match(/^[ \t]*/)?.[0] || "";
          } else if (lines.length > 0) {
            // If inserting at the very end, use indent of last line
            indent = lines[lines.length - 1].match(/^[ \t]*/)?.[0] || "";
          }

          const replaceLines = block.replace.split('\n');
          const replaceBaseIndent = getCommonIndent(block.replace);
          
          const reindentedReplaceLines = replaceLines.map(line => {
              if (line.trim() === "") return line;
              const dedentedLine = line.startsWith(replaceBaseIndent)
                ? line.substring(replaceBaseIndent.length)
                : line;
              return indent + dedentedLine;
          });

          lines.splice(insertionIndex, 0, ...reindentedReplaceLines);
          currentContent = lines.join("\n");
          continue;
        }

        const sourceLines = currentContent.split("\n");
        const searchLines = block.search.split("\n");
        const match = findBestMatch(sourceLines, searchLines, options.start_line ?? 1, options.end_line ?? sourceLines.length);

        if (match === null) {
          return createErrorResult(
            ERROR_CODES.SEARCH_BLOCK_NOT_FOUND,
            "Search block not found in the original content. The content to be replaced could not be located in the file, even with fuzzy matching."
          );
        }
        
        const { index: matchStartIndex } = match;
        const matchEndIndex = matchStartIndex + searchLines.length;
        
        const sourceMatchBlock = sourceLines.slice(matchStartIndex, matchEndIndex).join('\n');
        const sourceMatchIndent = getCommonIndent(sourceMatchBlock);

        const replaceLines = block.replace ? block.replace.split('\n') : [];
        const replaceBaseIndent = getCommonIndent(block.replace);
        
        const reindentedReplaceLines = replaceLines.map(line => {
            if (line.trim() === "") return "";
            const dedentedLine = line.startsWith(replaceBaseIndent)
              ? line.substring(replaceBaseIndent.length)
              : line;
            return sourceMatchIndent + dedentedLine;
        });

        const newSourceLines = [
          ...sourceLines.slice(0, matchStartIndex),
          ...reindentedReplaceLines,
          ...sourceLines.slice(matchEndIndex)
        ];

        currentContent = newSourceLines.join("\n");
      }

      return { success: true, content: currentContent };
    };
approved: true
