uuid: 13a446e1-255e-4734-918d-f2e7b3090626
projectId: diff-apply
createdAt: '2025-09-02T05:30:35.789Z'
linesAdded: 86
linesRemoved: 87
gitCommitMsg: 'refactor: introduce shared types and utils'
promptSummary: >-
  Refactor the project to include new utility and type files for better code
  organization.
reasoning:
  - >-
    ok, refactoring for better structure. i'll create some util and type files
    to DRY things up.
  - >-
    first, i'll create `src/types.ts` to house the shared `DiffError` and
    `ApplyDiffResult` types that are duplicated in both strategy files.
  - >-
    next, i'll extract all the error code strings into `src/constants.ts`. this
    will make them consistent and easier to manage.
  - >-
    now, a small error utility in `src/utils/error.ts` to standardize error
    object creation.
  - adding a placeholder logger in `src/utils/logger.ts` as requested.
  - now i'll refactor `standard-diff.ts` to use these new shared modules.
  - doing the same for `search-replace.ts`.
  - >-
    i'll add a main `index.ts` to export all the public APIs from a single entry
    point.
  - finally, i'll update `package.json` to point to the new entry file.
operations:
  - type: write
    path: src/types.ts
    content: |-
      export type DiffError = {
        code: string;
        message: string;
      };

      export type ApplyDiffResult =
        | { success: true; content: string }
        | { success: false; error: DiffError };
    patchStrategy: replace
  - type: write
    path: src/constants.ts
    content: |-
      export const ERROR_CODES = {
        // Standard Diff Errors
        INVALID_DIFF_FORMAT: "INVALID_DIFF_FORMAT",
        OVERLAPPING_HUNKS: "OVERLAPPING_HUNKS",
        CONTEXT_MISMATCH: "CONTEXT_MISMATCH",

        // Search/Replace Errors
        INSERTION_REQUIRES_LINE_NUMBER: "INSERTION_REQUIRES_LINE_NUMBER",
        INVALID_LINE_RANGE: "INVALID_LINE_RANGE",
        SEARCH_BLOCK_NOT_FOUND_IN_RANGE: "SEARCH_BLOCK_NOT_FOUND_IN_RANGE",
        SEARCH_BLOCK_NOT_FOUND: "SEARCH_BLOCK_NOT_FOUND",
      } as const;
    patchStrategy: replace
  - type: write
    path: src/utils/error.ts
    content: |-
      import type { ApplyDiffResult } from "../types";

      export const createErrorResult = (
        code: string,
        message: string
      ): Extract<ApplyDiffResult, { success: false }> => {
        return {
          success: false,
          error: { code, message },
        };
      };
    patchStrategy: replace
  - type: write
    path: src/utils/logger.ts
    content: |-
      // Placeholder for a more robust logger
      export const logger = {
        info: (...args: unknown[]) => console.log(...args),
        warn: (...args: unknown[]) => console.warn(...args),
        error: (...args: unknown[]) => console.error(...args),
      };
    patchStrategy: replace
  - type: write
    path: src/strategies/standard-diff.ts
    content: >-
      --- src/strategies/standard-diff.ts

      +++ src/strategies/standard-diff.ts

      @@ -1,13 +1,7 @@

      -type DiffError = {

      -  code: string;

      -  message: string;

      -};

      -

      -type ApplyDiffResult =

      -  | { success: true; content: string }

      -  | { success: false; error: DiffError };

      +import { ERROR_CODES } from "../constants";

      +import type { ApplyDiffResult } from "../types";

      +import { createErrorResult } from "../utils/error";
       
       type Hunk = {
         originalStartLine: number;
      @@ -242,15 +236,9 @@
       ): ApplyDiffResult => {
         const hunks = parseHunks(diffContent);
         if (!hunks) {
      -    return {

      -      success: false,

      -      error: {

      -        code: "INVALID_DIFF_FORMAT",

      -        message:

      -          "Invalid diff format. Could not parse any hunks from the diff
      content.",

      -      },

      -    };

      +    return createErrorResult(

      +      ERROR_CODES.INVALID_DIFF_FORMAT,

      +      "Invalid diff format. Could not parse any hunks from the diff
      content."

      +    );
         }
       
         for (let i = 0; i < hunks.length; i++) {
      @@ -263,15 +251,9 @@
               Math.max(h1.originalStartLine, h2.originalStartLine) <=
               Math.min(h1End, h2End)
             ) {
      -        return {

      -          success: false,

      -          error: {

      -            code: "OVERLAPPING_HUNKS",

      -            message:

      -              "Hunks overlap. The provided diff contains multiple change
      hunks that target the same or overlapping line ranges, creating an
      ambiguity that cannot be resolved.",

      -          },

      -        };

      +        return createErrorResult(

      +          ERROR_CODES.OVERLAPPING_HUNKS,

      +          "Hunks overlap. The provided diff contains multiple change
      hunks that target the same or overlapping line ranges, creating an
      ambiguity that cannot be resolved."

      +        );
             }
           }
         }
      @@ -285,16 +267,10 @@
           } else {
             const subHunks = splitHunk(hunk);
             if (subHunks.length <= 1) {
      -        return {

      -          success: false,

      -          error: {

      -            code: "CONTEXT_MISMATCH",

      -            message:

      -              "Could not apply modification. The context provided in the
      diff does not match the content of the file. Hunk splitting fallback was
      also unsuccessful.",

      -          },

      -        };

      +        return createErrorResult(

      +          ERROR_CODES.CONTEXT_MISMATCH,

      +          "Could not apply modification. The context provided in the diff
      does not match the content of the file. Hunk splitting fallback was also
      unsuccessful."

      +        );
             }
       
             let allApplied = true;
      @@ -308,16 +284,10 @@
               }
             }
             if (!allApplied) {
      -        return {

      -          success: false,

      -          error: {

      -            code: "CONTEXT_MISMATCH",

      -            message:

      -              "Could not apply modification. The context provided in the
      diff does not match the content of the file. Hunk splitting fallback was
      also unsuccessful.",

      -          },

      -        };

      +        return createErrorResult(

      +          ERROR_CODES.CONTEXT_MISMATCH,

      +          "Could not apply modification. The context provided in the diff
      does not match the content of the file. Hunk splitting fallback was also
      unsuccessful."

      +        );
             }
           }
         }
    patchStrategy: new-unified
  - type: write
    path: src/strategies/search-replace.ts
    content: >-
      --- src/strategies/search-replace.ts

      +++ src/strategies/search-replace.ts

      @@ -1,12 +1,6 @@

      -type DiffError = {

      -  code: string;

      -  message: string;

      -};

      -

      -type ApplyDiffResult =

      -  | { success: true; content: string }

      -  | { success: false; error: DiffError };

      +import { ERROR_CODES } from "../constants";

      +import type { ApplyDiffResult } from "../types";

      +import { createErrorResult } from "../utils/error";
       
       export const getToolDescription = (cwd: string): string => {
         return `apply_diff Tool: Search and Replace
      @@ -95,14 +89,11 @@
         );
       
         if (parts.length < 4) {
      -    return {

      -      success: false,

      -      error: {

      -        code: "INVALID_DIFF_FORMAT",

      -        message:

      -          "Invalid diff format. The diff must contain '<<<<<<< SEARCH',
      '=======', and '>>>>>>> REPLACE' markers.",

      -      },

      -    };

      +    return createErrorResult(

      +      ERROR_CODES.INVALID_DIFF_FORMAT,

      +      "Invalid diff format. The diff must contain '<<<<<<< SEARCH',
      '=======', and '>>>>>>> REPLACE' markers."

      +    );
         }
       
         // Using .trim() is too aggressive and removes indentation.
      @@ -116,15 +107,9 @@
       
         if (searchBlock === "") {
           if (typeof options.start_line !== "number") {
      -      return {

      -        success: false,

      -        error: {

      -          code: "INSERTION_REQUIRES_LINE_NUMBER",

      -          message:

      -            "Insertion requires a start_line. The SEARCH block was empty,
      but no start_line was provided to specify the insertion point.",

      -        },

      -      };

      +      return createErrorResult(

      +        ERROR_CODES.INSERTION_REQUIRES_LINE_NUMBER,

      +        "Insertion requires a start_line. The SEARCH block was empty, but
      no start_line was provided to specify the insertion point."

      +      );
           }
           const lines = original_content.split("\n");
           const insertionIndex = Math.max(0, options.start_line - 1);
      @@ -139,14 +124,11 @@
           const { start_line, end_line } = options;
       
           if (start_line < 1 || end_line > lines.length || start_line > end_line) {
      -      return {

      -        success: false,

      -        error: {

      -          code: "INVALID_LINE_RANGE",

      -          message: "Invalid line range for constrained search.",

      -        },

      -      };

      +      return createErrorResult(

      +        ERROR_CODES.INVALID_LINE_RANGE,

      +        "Invalid line range for constrained search."

      +      );
           }
       
           const preSlice = lines.slice(0, start_line - 1);
      @@ -155,14 +137,11 @@
       
           const targetText = targetSlice.join("\n");
           if (!targetText.includes(searchBlock)) {
      -      return {

      -        success: false,

      -        error: {

      -          code: "SEARCH_BLOCK_NOT_FOUND_IN_RANGE",

      -          message: "Search block not found in the specified line range.",

      -        },

      -      };

      +      return createErrorResult(

      +        ERROR_CODES.SEARCH_BLOCK_NOT_FOUND_IN_RANGE,

      +        "Search block not found in the specified line range."

      +      );
           }
           const newTargetText = targetText.replace(searchBlock, replaceBlock);
       
      @@ -175,14 +154,11 @@
         }
       
         if (!original_content.includes(searchBlock)) {
      -    return {

      -      success: false,

      -      error: {

      -        code: "SEARCH_BLOCK_NOT_FOUND",

      -        message:

      -          "Search block not found in the original content. The content to
      be replaced could not be located in the file.",

      -      },

      -    };

      +    return createErrorResult(

      +      ERROR_CODES.SEARCH_BLOCK_NOT_FOUND,

      +      "Search block not found in the original content. The content to be
      replaced could not be located in the file."

      +    );
         }
       
         let newContent = original_content.replace(searchBlock, replaceBlock);
    patchStrategy: new-unified
  - type: write
    path: src/index.ts
    content: |-
      export * from "./strategies/standard-diff";
      export * from "./strategies/search-replace";
      export * from "./types";
      export * from "./constants";
      export * from "./utils/error";
      export * from "./utils/logger";
    patchStrategy: replace
  - type: write
    path: package.json
    content: |-
      --- package.json
      +++ package.json
      @@ -1,6 +1,6 @@
       {
         "name": "diff-apply",
      -  "module": "index.ts",
      +  "module": "src/index.ts",
         "type": "module",
         "devDependencies": {
           "bun-types": "latest",
    patchStrategy: new-unified
snapshot:
  src/types.ts: null
  src/constants.ts: null
  src/utils/error.ts: null
  src/utils/logger.ts: null
  src/index.ts: null
  src/strategies/standard-diff.ts: >
    type DiffError = {
      code: string;
      message: string;
    };


    type ApplyDiffResult =
      | { success: true; content: string }
      | { success: false; error: DiffError };

    type Hunk = {
      originalStartLine: number;
      originalLineCount: number;
      lines: string[];
    };


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Standard Diff Format

    Applies changes to a single file using the standard unified diff format (the
    same format used by \`git diff\`). This tool is highly resilient and can
    apply partial changes even if some parts of the diff do not match perfectly,
    by intelligently splitting changes into smaller parts.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing the changes in the unified diff format.

    Format Requirements:

    The \`diff_content\` must start with \`---\` and \`+++\` headers, followed
    by one or more \`@@ ... @@\` hunk headers.


    - Lines starting with \` \` (a space) are context and must match the
    original file.

    - Lines starting with \`-\` will be removed.

    - Lines starting with \`+\` will be added.


    Example:


    <apply_diff file_path="src/component.tsx">

    \`\`\`diff

    --- a/src/component.tsx

    +++ b/src/component.tsx

    @@ -10,7 +10,8 @@
     function MyComponent() {
    -  const [count, setCount] = useState(0);

    +  const [count, setCount] = useState(1);

    +  const [name, setName] = useState('');

       return (
         <div>
    \`\`\`

    </apply_diff>`;

    };


    const parseHunks = (diffContent: string): Hunk[] | null => {
      const lines = diffContent.split("\n");
      const hunks: Hunk[] = [];
      let currentHunk: Hunk | null = null;
      const hunkHeaderRegex = /^@@ -(\d+)(,(\d+))? \+(\d+)(,(\d+))? @@/;

      for (const line of lines) {
        if (line.startsWith("---") || line.startsWith("+++")) continue;

        const match = line.match(hunkHeaderRegex);
        if (match) {
          if (currentHunk) hunks.push(currentHunk);
          currentHunk = {
            originalStartLine: parseInt(match[1], 10),
            originalLineCount: match[3] ? parseInt(match[3], 10) : 1,
            lines: [],
          };
        } else if (
          currentHunk &&
          (line.startsWith(" ") || line.startsWith("+") || line.startsWith("-"))
        ) {
          currentHunk.lines.push(line);
        }
      }
      if (currentHunk) hunks.push(currentHunk);
      return hunks.length > 0 ? hunks : null;
    };


    const levenshtein = (s1: string, s2: string): number => {
      if (s1.length < s2.length) {
        return levenshtein(s2, s1);
      }
      if (s2.length === 0) {
        return s1.length;
      }
      let previousRow = Array.from({ length: s2.length + 1 }, (_, i) => i);
      for (let i = 0; i < s1.length; i++) {
        let currentRow = [i + 1];
        for (let j = 0; j < s2.length; j++) {
          const insertions = previousRow[j + 1] + 1;
          const deletions = currentRow[j] + 1;
          const substitutions = previousRow[j] + (s1[i] === s2[j] ? 0 : 1);
          currentRow.push(Math.min(insertions, deletions, substitutions));
        }
        previousRow = currentRow;
      }
      return previousRow[previousRow.length - 1];
    };


    const applyHunk = (
      sourceLines: readonly string[],
      hunk: Hunk
    ): { success: true; newLines: string[] } | { success: false } => {
      if (hunk.lines.every((l) => l.startsWith("+"))) {
        const result = [...sourceLines];
        const additions = hunk.lines.map((l) => l.substring(1));
        const insertionPoint =
          hunk.originalStartLine > 0 ? hunk.originalStartLine - 1 : 0;
        result.splice(insertionPoint, 0, ...additions);
        return { success: true, newLines: result };
      }

      const pattern = hunk.lines
        .filter((l) => l.startsWith(" ") || l.startsWith("-"))
        .map((l) => l.substring(1));

      if (pattern.length === 0) {
        const result = [...sourceLines];
        const additions = hunk.lines
          .filter((l) => l.startsWith("+"))
          .map((l) => l.substring(1));
        result.splice(hunk.originalStartLine - 1, 0, ...additions);
        return { success: true, newLines: result };
      }

      let bestMatchIndex = -1;
      let minDistance = Infinity;
      const patternText = pattern.join("\n");
      // Don't allow fuzzy matching for very small patterns to avoid incorrect matches.
      const useFuzzy = patternText.length > 20;
      const maxDistanceThreshold = Math.max(
        5,
        Math.floor(patternText.length * 0.4)
      );

      for (let i = 0; i <= sourceLines.length - pattern.length; i++) {
        const slice = sourceLines.slice(i, i + pattern.length);
        const sliceText = slice.join("\n");
        const distance = useFuzzy
          ? levenshtein(patternText, sliceText)
          : sliceText === patternText
            ? 0
            : Infinity;

        if (distance < minDistance) {
          minDistance = distance;
          bestMatchIndex = i;
        }
        if (distance === 0) break; // Perfect match found
      }

      if (bestMatchIndex === -1 || (useFuzzy && minDistance > maxDistanceThreshold)) {
        return { success: false };
      }

      const result: string[] = [...sourceLines.slice(0, bestMatchIndex)];
      let sourceIdx = bestMatchIndex;

      for (const hunkLine of hunk.lines) {
        const lineContent = hunkLine.substring(1);
        if (hunkLine.startsWith("+")) {
          result.push(lineContent);
        } else if (hunkLine.startsWith(" ")) {
          // For context lines, use the content from the source file to preserve it
          // perfectly, especially after a fuzzy match.
          if (sourceIdx < sourceLines.length) {
            result.push(sourceLines[sourceIdx]);
          }
          sourceIdx++;
        } else if (hunkLine.startsWith("-")) {
          // For removed lines, just advance the source pointer.
          sourceIdx++;
        }
      }
      result.push(...sourceLines.slice(sourceIdx));
      return { success: true, newLines: result };
    };


    const splitHunk = (hunk: Hunk): Hunk[] => {
      const subHunks: Hunk[] = [];
      const context = 2;
      let i = 0;
      while (i < hunk.lines.length) {
        while (i < hunk.lines.length && hunk.lines[i].startsWith(" ")) i++;
        if (i === hunk.lines.length) break;

        const changeStart = i;
        while (i < hunk.lines.length && !hunk.lines[i].startsWith(" ")) i++;
        const changeEnd = i;

        const start = Math.max(0, changeStart - context);
        const end = Math.min(hunk.lines.length, changeEnd + context);

        subHunks.push({
          ...hunk,
          lines: hunk.lines.slice(start, end),
        });
      }
      return subHunks;
    };


    export const applyDiff = (
      originalContent: string,
      diffContent: string
    ): ApplyDiffResult => {
      const hunks = parseHunks(diffContent);
      if (!hunks) {
        return {
          success: false,
          error: {
            code: "INVALID_DIFF_FORMAT",
            message:
              "Invalid diff format. Could not parse any hunks from the diff content.",
          },
        };
      }

      for (let i = 0; i < hunks.length; i++) {
        for (let j = i + 1; j < hunks.length; j++) {
          const h1 = hunks[i];
          const h1End = h1.originalStartLine + h1.originalLineCount - 1;
          const h2 = hunks[j];
          const h2End = h2.originalStartLine + h2.originalLineCount - 1;
          if (
            Math.max(h1.originalStartLine, h2.originalStartLine) <=
            Math.min(h1End, h2End)
          ) {
            return {
              success: false,
              error: {
                code: "OVERLAPPING_HUNKS",
                message:
                  "Hunks overlap. The provided diff contains multiple change hunks that target the same or overlapping line ranges, creating an ambiguity that cannot be resolved.",
              },
            };
          }
        }
      }

      let lines: readonly string[] = originalContent.split("\n");

      for (const hunk of hunks) {
        const result = applyHunk(lines, hunk);
        if (result.success) {
          lines = result.newLines;
        } else {
          const subHunks = splitHunk(hunk);
          if (subHunks.length <= 1) {
            return {
              success: false,
              error: {
                code: "CONTEXT_MISMATCH",
                message:
                  "Could not apply modification. The context provided in the diff does not match the content of the file. Hunk splitting fallback was also unsuccessful.",
              },
            };
          }

          let allApplied = true;
          for (const subHunk of subHunks) {
            const subResult = applyHunk(lines, subHunk);
            if (subResult.success) {
              lines = subResult.newLines;
            } else {
              allApplied = false;
              break;
            }
          }
          if (!allApplied) {
            return {
              success: false,
              error: {
                code: "CONTEXT_MISMATCH",
                message:
                  "Could not apply modification. The context provided in the diff does not match the content of the file. Hunk splitting fallback was also unsuccessful.",
              },
            };
          }
        }
      }

      return { success: true, content: lines.join("\n") };
    };
  src/strategies/search-replace.ts: >
    type DiffError = {
      code: string;
      message: string;
    };


    type ApplyDiffResult =
      | { success: true; content: string }
      | { success: false; error: DiffError };

    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Search and Replace

    Applies a targeted code change to a single file using a search-and-replace
    format. This is ideal for precise modifications, insertions, or deletions of
    specific code blocks.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing the search and replace blocks.
      :start_line: (optional) The line number in the original file where the search block is expected to start. Use this to resolve ambiguity when the same code appears multiple times. Required for insertions.
      :end_line: (optional) The line number in the original file where the search block is expected to end.

    Format Requirements:

    The \`diff_content\` must follow this structure:


    <file_path_ignored_but_useful_for_context>

    <<<<<<< SEARCH

    [content to find]

    =======

    [content to replace with]

    >>>>>>> REPLACE


    Special Cases:

    - To INSERT code, leave the SEARCH block empty and provide a \`start_line\`.
    The new code will be inserted before that line.

    - To DELETE code, leave the REPLACE block empty.


    Examples:


    1. Basic Replace:

    <apply_diff file_path="src/utils.ts">
      src/utils.ts
      <<<<<<< SEARCH
      function oldFunction() {
        return 1;
      }
      =======
      function newFunction() {
        return 2;
      }
      >>>>>>> REPLACE
    </apply_diff>


    2. Insertion (note the empty SEARCH block and \`start_line\`):

    <apply_diff file_path="src/app.ts" start_line="5">
      src/app.ts
      <<<<<<< SEARCH
      =======
      import { NewDependency } from './new-dependency';
      >>>>>>> REPLACE
    </apply_diff>`;

    };


    const stripLineNumbers = (text: string): string => {
      return text
        .split("\n")
        .map((line) => {
          // Remove line numbers in format "N |" or "N|" where N is a number
          // This preserves the original indentation after the pipe
          const match = line.match(/^\s*\d+\s*\|\s*(.*)/);
          return match ? match[1] : line;
        })
        .join("\n");
    };


    export const applyDiff = (
      original_content: string,
      diff_content: string,
      options: { start_line?: number; end_line?: number } = {}
    ): ApplyDiffResult => {
      let diff = diff_content;
      const firstLineEnd = diff.indexOf("\n");
      if (
        firstLineEnd !== -1 &&
        !diff.substring(0, firstLineEnd).includes("<<<<<<<")
      ) {
        diff = diff.substring(firstLineEnd + 1);
      }

      const parts = diff.split(
        /^\s*<<<<<<< SEARCH\s*$|^\s*=======*\s*$|^\s*>>>>>>> REPLACE\s*$/m
      );

      if (parts.length < 4) {
        return {
          success: false,
          error: {
            code: "INVALID_DIFF_FORMAT",
            message:
              "Invalid diff format. The diff must contain '<<<<<<< SEARCH', '=======', and '>>>>>>> REPLACE' markers.",
          },
        };
      }

      // Using .trim() is too aggressive and removes indentation.
      // We want to remove the leading/trailing newlines that result from the split,
      // but preserve the indentation of the code itself.
      // Remove leading and trailing newlines, but preserve internal structure
      const cleanBlock = (block: string) => block.replace(/^\r?\n/, "").replace(/\r?\n$/, "").replace(/([ \t]+)$/, "");
      let [, searchBlock, replaceBlock] = parts;
      searchBlock = stripLineNumbers(cleanBlock(searchBlock));
      replaceBlock = stripLineNumbers(cleanBlock(replaceBlock));

      if (searchBlock === "") {
        if (typeof options.start_line !== "number") {
          return {
            success: false,
            error: {
              code: "INSERTION_REQUIRES_LINE_NUMBER",
              message:
                "Insertion requires a start_line. The SEARCH block was empty, but no start_line was provided to specify the insertion point.",
            },
          };
        }
        const lines = original_content.split("\n");
        const insertionIndex = Math.max(0, options.start_line - 1);
        // Split the replaceBlock into lines and insert each line
        const replaceLines = replaceBlock.split("\n");
        lines.splice(insertionIndex, 0, ...replaceLines);
        return { success: true, content: lines.join("\n") };
      }

      if (options.start_line && options.end_line) {
        const lines = original_content.split("\n");
        const { start_line, end_line } = options;

        if (start_line < 1 || end_line > lines.length || start_line > end_line) {
          return {
            success: false,
            error: {
              code: "INVALID_LINE_RANGE",
              message: "Invalid line range for constrained search.",
            },
          };
        }

        const preSlice = lines.slice(0, start_line - 1);
        const targetSlice = lines.slice(start_line - 1, end_line);
        const postSlice = lines.slice(end_line);

        const targetText = targetSlice.join("\n");
        if (!targetText.includes(searchBlock)) {
          return {
            success: false,
            error: {
              code: "SEARCH_BLOCK_NOT_FOUND_IN_RANGE",
              message: "Search block not found in the specified line range.",
            },
          };
        }
        const newTargetText = targetText.replace(searchBlock, replaceBlock);

        const newContent = [
          ...preSlice,
          ...newTargetText.split("\n"),
          ...postSlice,
        ].join("\n");
        return { success: true, content: newContent };
      }

      if (!original_content.includes(searchBlock)) {
        return {
          success: false,
          error: {
            code: "SEARCH_BLOCK_NOT_FOUND",
            message:
              "Search block not found in the original content. The content to be replaced could not be located in the file.",
          },
        };
      }

      let newContent = original_content.replace(searchBlock, replaceBlock);
      
      // If we're deleting content (replaceBlock is empty), clean up extra newlines
      if (replaceBlock === "") {
        // Remove double newlines that might result from deletion
        newContent = newContent.replace(/\n\n+/g, "\n");
      }
      
      return { success: true, content: newContent };
    };
  package.json: |-
    {
      "name": "diff-apply",
      "module": "index.ts",
      "type": "module",
      "devDependencies": {
        "bun-types": "latest",
        "js-yaml": "^4.1.0",
        "@types/js-yaml": "^4.0.9"
      },
      "peerDependencies": {
        "typescript": "^5.0.0"
      }
    }
approved: true
