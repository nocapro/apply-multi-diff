uuid: 1357f02d-ba32-4752-9b2e-06a19f6a738c
projectId: diff-apply
createdAt: '2025-09-02T13:41:37.383Z'
linesAdded: 205
linesRemoved: 0
gitCommitMsg: 'test: add complex test cases for both strategies'
promptSummary: add more complex test cases to battle test
reasoning:
  - >-
    Alright, let's battle-test this diffing logic. I've cooked up some gnarly
    test cases for both strategies to check edge cases like fuzzy matching with
    semantic changes, hunk splitting after user edits, and complex indentation
    scenarios.
  - >-
    First, I'll add a small code change to `search-replace.ts` to correctly
    handle insertions into empty files.
  - >-
    Now, let's beef up the test fixtures for the search-replace strategy. These
    new tests will check fuzzy matching guardrails, complex indentation, empty
    file insertions, and how ambiguous matches are handled.
  - >-
    Next, I'll add more challenging tests for the standard diff strategy,
    focusing on fuzzy matching with drifted context, hunk splitting resilience,
    pure insertions, and hunk splitting failures.
  - >-
    These tests should give us much higher confidence in the robustness of the
    diffing logic.
operations:
  - type: write
    path: src/strategies/search-replace.ts
    content: |-
      --- src/strategies/search-replace.ts
      +++ src/strategies/search-replace.ts
      @@ -213,6 +213,12 @@
                 "Insertion requires a start_line. A SEARCH block was empty, but no start_line was provided."
               );
             }
      +      // Special case for inserting into an empty file
      +      if (currentContent === "") {
      +        currentContent = block.replace;
      +        continue;
      +      }
      +
             const lines = currentContent.split("\n");
             const insertionIndex = Math.max(0, options.start_line - 1);
             const replaceLines = block.replace.split("\n");
    patchStrategy: new-unified
  - type: write
    path: test/fixtures/search-replace.yml
    content: >-
      --- test/fixtures/search-replace.yml

      +++ test/fixtures/search-replace.yml

      @@ -216,3 +216,84 @@
           content: |
             const a = "apricot";
             const b = "blueberry";
      +

      +  - name: fuzzy-match-rejection-on-string-literal-change

      +    description: Should reject a fuzzy match that changes the semantic
      meaning of a string literal

      +    input:

      +      original_content: |

      +        logger.error("Failed to connect to database");

      +      diff_content: |

      +        test.ts

      +        <<<<<<< SEARCH

      +        logger.error("Failed to load configuration");

      +        =======

      +        Sentry.captureMessage("Failed to load configuration");

      +        >>>>>>> REPLACE

      +    expected:

      +      success: false

      +      reason: "Search block not found"

      +

      +  - name: replace-with-complex-relative-indentation

      +    description: Should correctly re-indent a replacement block with
      multiple indentation levels

      +    input:

      +      original_content: |

      +        function outer() {

      +            if (condition) {

      +                process();

      +            }

      +        }

      +      diff_content: |

      +        test.ts

      +        <<<<<<< SEARCH

      +        process();

      +        =======

      +        if (anotherCondition) {

      +            process();

      +        } else {

      +            fallback();

      +        }

      +        >>>>>>> REPLACE

      +    expected:

      +      success: true

      +      content: |

      +        function outer() {

      +            if (condition) {

      +                if (anotherCondition) {

      +                    process();

      +                } else {

      +                    fallback();

      +                }

      +            }

      +        }

      +

      +  - name: empty-file-insertion

      +    description: Should insert content into an empty file without extra
      newlines

      +    input:

      +      original_content: ""

      +      diff_content: |

      +        test.ts

      +        <<<<<<< SEARCH

      +        =======

      +        Hello, World!

      +        >>>>>>> REPLACE

      +      start_line: 1

      +    expected:

      +      success: true

      +      content: "Hello, World!"

      +

      +  - name: first-of-ambiguous-match-is-replaced

      +    description: Should replace the first occurrence of an ambiguous
      match when no line numbers are given

      +    input:

      +      original_content: |

      +        config.set("value", 1);

      +        // ... lots of code

      +        config.set("value", 1);

      +      diff_content: |

      +        test.ts

      +        <<<<<<< SEARCH

      +        config.set("value", 1);

      +        =======

      +        config.set("value", 2);

      +        >>>>>>> REPLACE

      +    expected:

      +      success: true

      +      content: |

      +        config.set("value", 2);

      +        // ... lots of code

      +        config.set("value", 1);
    patchStrategy: new-unified
  - type: write
    path: test/fixtures/standard-diff.yml
    content: >-
      --- test/fixtures/standard-diff.yml

      +++ test/fixtures/standard-diff.yml

      @@ -211,3 +211,102 @@
           expected:
             success: false
             reason: "Hunks overlap"
      +

      +  - name: fuzzy-match-with-actual-drift

      +    description: Should apply a hunk using fuzzy matching when context
      has drifted due to new comments

      +    input:

      +      original_content: |

      +        // User added a comment here

      +        class MyComponent extends React.Component {

      +          render() {

      +            const { value } = this.props;

      +            // And another comment here

      +            return <div>{value}</div>;

      +          }

      +        }

      +      diff_content: |

      +        --- a/component.jsx

      +        +++ b/component.jsx

      +        @@ -2,5 +2,5 @@

      +         class MyComponent extends React.Component {

      +           render() {

      +             const { value } = this.props;

      +        -    return <div>{value}</div>;

      +        +    return <p>{value}</p>;

      +           }

      +         }

      +    expected:

      +      success: true

      +      content: |

      +        // User added a comment here

      +        class MyComponent extends React.Component {

      +          render() {

      +            const { value } = this.props;

      +            // And another comment here

      +            return <p>{value}</p>;

      +          }

      +        }

      +

      +  - name: hunk-splitting-with-intermediate-user-edit

      +    description: Should succeed by splitting a hunk when a user edit
      breaks its contiguity

      +    input:

      +      original_content: |

      +        function setup() {

      +            console.log("Initializing part 1...");

      +            // init

      +        }

      +

      +        // User added a new function here, breaking the hunk's contiguity

      +        function helper() {

      +            return true;

      +        }

      +

      +        function tearDown() {

      +            console.log("Tearing down part 3...");

      +            // teardown

      +        }

      +      diff_content: |

      +        --- a/file.js

      +        +++ b/file.js

      +        @@ -1,8 +1,8 @@

      +         function setup() {

      +        -    console.log("Initializing part 1...");

      +        -    // init

      +        +    console.log("Initializing part 1... DONE");

      +        +    // initialize

      +         }

      +         

      +         function tearDown() {

      +        -    console.log("Tearing down part 3...");

      +        -    // teardown

      +        +    console.log("Tearing down part 3... DONE");

      +        +    // deinitialize

      +         }

      +    expected:

      +      success: true

      +      content: |

      +        function setup() {

      +            console.log("Initializing part 1... DONE");

      +            // initialize

      +        }

      +

      +        // User added a new function here, breaking the hunk's contiguity

      +        function helper() {

      +            return true;

      +        }

      +

      +        function tearDown() {

      +            console.log("Tearing down part 3... DONE");

      +            // deinitialize

      +        }

      +

      +  - name: hunk-splitting-failure

      +    description: Should fail if a sub-hunk fails to apply after splitting

      +    input:

      +      original_content: |

      +        function partA() {

      +            // some code A

      +        }

      +        function partB() {

      +            // completely different code B

      +        }

      +      diff_content: |

      +        --- a/file.js

      +        +++ b/file.js

      +        @@ -1,5 +1,5 @@

      +         function partA() {

      +        -    // some code A

      +        +    // new code A

      +         }

      +         function partB() {

      +        -    // some code B

      +        +    // new code B

      +         }

      +    expected:

      +      success: false

      +      reason: "Could not apply modification"
    patchStrategy: new-unified
snapshot:
  src/strategies/search-replace.ts: >-
    import { ERROR_CODES } from "../constants";

    import type { ApplyDiffResult } from "../types";

    import { createErrorResult } from "../utils/error";

    import { getCommonIndent, levenshtein, dedent } from "../utils/string";


    export const getToolDescription = (cwd: string): string => {
      return `apply_diff Tool: Search and Replace

    Applies a targeted code change to a single file using a search-and-replace
    format. This is ideal for precise modifications, insertions, or deletions of
    specific code blocks. It supports fuzzy matching and multiple replacements
    in a single call.


    Parameters:
      :file_path: (required) The path to the file to modify, relative to the current working directory ${cwd}.
      :diff_content: (required) A string containing one or more search and replace blocks.
      :start_line: (optional) The line number in the original file where the search block is expected to start. Use this to resolve ambiguity when the same code appears multiple times. Required for insertions.
      :end_line: (optional) The line number in the original file where the search block is expected to end.

    Format Requirements:

    The \`diff_content\` must follow this structure. You can include multiple
    blocks.


    <file_path_ignored_but_useful_for_context>

    <<<<<<< SEARCH

    [content to find and replace]

    =======

    [new content to insert]

    >>>>>>> REPLACE


    Special Cases:

    - To INSERT code, leave the SEARCH block empty and provide a \`start_line\`.
    The new code will be inserted before that line.

    - To DELETE code, leave the REPLACE block empty.


    Examples:


    1. Fuzzy Replace (will match even if comments are slightly different):

    <apply_diff file_path="src/utils.ts">
      src/utils.ts
      <<<<<<< SEARCH
      // old function
      function oldFunction() {
        return 1;
      }
      =======
      // new, improved function
      function newFunction() {
        return 2;
      }
      >>>>>>> REPLACE
    </apply_diff>


    2. Insertion (note the empty SEARCH block and \`start_line\`):

    <apply_diff file_path="src/app.ts" start_line="5">
      src/app.ts
      <<<<<<< SEARCH
      =======
      // Add a new configuration setting
      const newConfig = initializeNewDependency();
      >>>>>>> REPLACE
    </apply_diff>`;

    };


    const stripLineNumbers = (text: string): string => {
      const lines = text.split("\n");
      const allLinesNumbered = lines
        .filter((line) => line.trim() !== "")
        .every((line) => /^\s*\d+\s*\|/.test(line));
      if (!allLinesNumbered) return text;
      return lines.map((line) => line.replace(/^\s*\d+\s*\|\s?/, "")).join("\n");
    };


    const cleanBlock = (block: string) =>
      block.replace(/^\r?\n/, "").replace(/\r?\n?$/, "");

    type SearchReplaceBlock = { search: string; replace: string };


    const parseDiff = (diffContent: string): SearchReplaceBlock[] | null => {
      const blocks: SearchReplaceBlock[] = [];
      const searchMarker = /^\s*<<<<<<< SEARCH\s*$/m;
      const replaceMarker = /^\s*>>>>>>> REPLACE\s*$/m;

      let content = diffContent;
      const firstLineEnd = content.indexOf("\n");
      if (firstLineEnd !== -1 && !content.substring(0, firstLineEnd).includes("<<<<<<<")) {
        content = content.substring(firstLineEnd + 1);
      }

      while (searchMarker.test(content)) {
        const searchStart = content.search(searchMarker);
        const replaceEndMatch = content.match(replaceMarker);
        if (!replaceEndMatch || typeof replaceEndMatch.index === "undefined") break;
        
        const replaceEnd = replaceEndMatch.index + replaceEndMatch[0].length;
        const blockContent = content.substring(searchStart, replaceEnd);
        
        const parts = blockContent.split(
          /^\s*<<<<<<< SEARCH\s*$|^\s*=======*\s*$|^\s*>>>>>>> REPLACE\s*$/m
        );
        
        if (parts.length >= 4) {
          blocks.push({
            search: stripLineNumbers(cleanBlock(parts[1])),
            replace: stripLineNumbers(cleanBlock(parts[2])),
          });
        }
        content = content.substring(replaceEnd);
      }

      return blocks.length > 0 ? blocks : null;
    };


    const findBestMatch = (
      sourceLines: readonly string[],
      searchLines: readonly string[],
      startLine: number,
      endLine: number
    ): { index: number; distance: number } | null => {
      if (searchLines.length === 0) return null;

      let bestMatchIndex = -1;
      let minDistance = Infinity;
      const searchText = searchLines.join("\n");
      const dedentedSearchText = dedent(searchText);
      const maxDistanceThreshold = Math.max(
        5, // a minimum for short blocks
        Math.floor(dedentedSearchText.length * 0.3) // 30% tolerance for fuzzy matching
      );

      const searchStart = startLine - 1;
      const searchEnd = endLine ?? sourceLines.length;

      for (let i = searchStart; i <= searchEnd - searchLines.length; i++) {
        const slice = sourceLines.slice(i, i + searchLines.length);
        const sliceText = slice.join("\n");
        const dedentedSliceText = dedent(sliceText);
        const distance = levenshtein(dedentedSearchText, dedentedSliceText);
        if (distance < minDistance) {
          minDistance = distance;
          bestMatchIndex = i;
        }
        if (distance === 0) break;
      }
      if (bestMatchIndex === -1 || minDistance > maxDistanceThreshold) {
        return null;
      }
      
      // Additional check: if a change was detected, reject if it looks like a semantic change inside a string literal
      if (minDistance > 0) {
        const slice = sourceLines.slice(bestMatchIndex, bestMatchIndex + searchLines.length);
        const sliceText = slice.join("\n");
        const dedentedSliceText = dedent(sliceText);
        
        // Check if both contain string literals and they're different
        const searchHasString = /["'].*["']/.test(dedentedSearchText);
        const sliceHasString = /["'].*["']/.test(dedentedSliceText);
        
        if (searchHasString && sliceHasString) {
          // Extract the string content to see if it's a semantic change
          const searchStringMatch = dedentedSearchText.match(/["'](.*?)["']/);
          const sliceStringMatch = dedentedSliceText.match(/["'](.*?)["']/);
          
          if (searchStringMatch && sliceStringMatch) {
            const searchString = searchStringMatch[1];
            const sliceString = sliceStringMatch[1];
            
            // If the strings are completely different (not just comment changes), reject
            if (searchString !== sliceString && !searchString.includes(sliceString) && !sliceString.includes(searchString)) {
              return null;
            }
          }
        }
      }
      return { index: bestMatchIndex, distance: minDistance };
    };


    export const applyDiff = (
      original_content: string,
      diff_content: string,
      options: { start_line?: number; end_line?: number } = {}
    ): ApplyDiffResult => {
      const blocks = parseDiff(diff_content);
      if (!blocks) {
        return createErrorResult(
          ERROR_CODES.INVALID_DIFF_FORMAT,
          "Invalid diff format. Could not parse any '<<<<<<< SEARCH'...'>>>>>>> REPLACE' blocks."
        );
      }

      let currentContent = original_content;

      for (const block of blocks) {
        if (block.search === "") {
          // Pure insertion
          if (typeof options.start_line !== "number") {
            return createErrorResult(
              ERROR_CODES.INSERTION_REQUIRES_LINE_NUMBER,
              "Insertion requires a start_line. A SEARCH block was empty, but no start_line was provided."
            );
          }
          const lines = currentContent.split("\n");
          const insertionIndex = Math.max(0, options.start_line - 1);
          const replaceLines = block.replace.split("\n");
          lines.splice(insertionIndex, 0, ...replaceLines);
          currentContent = lines.join("\n");
          continue;
        }

        const sourceLines = currentContent.split("\n");
        const searchLines = block.search.split("\n");
        const match = findBestMatch(sourceLines, searchLines, options.start_line ?? 1, options.end_line ?? sourceLines.length);

        if (match === null) {
          return createErrorResult(
            ERROR_CODES.SEARCH_BLOCK_NOT_FOUND,
            "Search block not found in the original content. The content to be replaced could not be located in the file, even with fuzzy matching."
          );
        }
        
        const { index: matchStartIndex } = match;
        const matchEndIndex = matchStartIndex + searchLines.length;
        
        const sourceMatchBlock = sourceLines.slice(matchStartIndex, matchEndIndex).join('\n');
        const sourceMatchIndent = getCommonIndent(sourceMatchBlock);

        const replaceLines = block.replace ? block.replace.split('\n') : [];
        const replaceBaseIndent = getCommonIndent(block.replace);
        
        const reindentedReplaceLines = replaceLines.map(line => {
            if (line.trim() === "") return "";
            const dedentedLine = line.startsWith(replaceBaseIndent)
              ? line.substring(replaceBaseIndent.length)
              : line;
            return sourceMatchIndent + dedentedLine;
        });

        const newSourceLines = [
          ...sourceLines.slice(0, matchStartIndex),
          ...reindentedReplaceLines,
          ...sourceLines.slice(matchEndIndex)
        ];

        currentContent = newSourceLines.join("\n");
      }

      return { success: true, content: currentContent };
    };
  test/fixtures/search-replace.yml: |-
    # Tests for the `getToolDescription` function
    tool_description_tests:
      - name: description-contains-key-elements
        description: Should generate a description that includes the CWD and format requirements
        input:
          cwd: "/mock/workspace"
        expected_to_contain:
          - "current working directory /mock/workspace"
          - "<<<<<<< SEARCH"
          - "======="
          - ">>>>>>> REPLACE"
          - "start_line"
          - "end_line"

    # Tests for the `applyDiff` function
    apply_diff_tests:
      - name: replace-exact-match
        description: Should replace content that is an exact match
        input:
          original_content: |
            function hello() {
                console.log("hello")
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function hello() {
                console.log("hello")
            }
            =======
            function hello() {
                console.log("hello world");
            }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function hello() {
                console.log("hello world");
            }

      - name: preserve-indentation-on-addition
        description: Should preserve original indentation when adding new lines
        input:
          original_content: |
            class Example {
                getValue() {
                    return this.value
                }
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                getValue() {
                    return this.value
                }
            =======
                getValue() {
                    // Add logging
                    console.log("Getting value");
                    return this.value;
                }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            class Example {
                getValue() {
                    // Add logging
                    console.log("Getting value");
                    return this.value;
                }
            }

      - name: fuzzy-match-on-minor-difference
        description: Should find and replace content that is slightly different from the search block
        input:
          original_content: |
            function calculate() {
              // A comment
              const result = 1 + 1;
              return result;
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
              // An old comment
              const result = 1 + 1;
            =======
              const result = 2 * 2; // updated logic
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            function calculate() {
              const result = 2 * 2; // updated logic
              return result;
            }

      - name: fail-on-no-match
        description: Should fail gracefully if the search content does not match
        input:
          original_content: |
            function hello() {
                console.log("hello")
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function hello() {
                console.log("wrong")
            }
            =======
            function hello() {
                console.log("hello world")
            }
            >>>>>>> REPLACE
        expected:
          success: false
          reason: "Search block not found"

      - name: indentation-agnostic-search-and-preserve
        description: Should find content regardless of its indentation and preserve it on replace
        input:
          original_content: |
                function test() {
                    return true;
                }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            function test() {
                return true;
            }
            =======
            function test() {
                return false;
            }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
                function test() {
                    return false;
                }

      - name: respect-relative-indentation-in-replace
        description: Should respect the relative indentation inside the REPLACE block
        input:
          original_content: |
            class Test {
                method() {
                    console.log("test");
                }
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                method() {
                    console.log("test");
                }
            =======
                method() {
                    try {
                        if (true) {
                            console.log("test");
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            class Test {
                method() {
                    try {
                        if (true) {
                            console.log("test");
                        }
                    } catch (e) {
                        console.error(e);
                    }
                }
            }

      - name: fail-on-invalid-format
        description: Should fail gracefully if the diff format is invalid
        input:
          original_content: "function hello() {}"
          diff_content: "This is not a valid format"
        expected:
          success: false
          reason: "Invalid diff format"

      - name: strip-line-numbers
        description: Should strip leading line numbers from search and replace blocks
        input:
          original_content: "    return true;"
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            2 |     return true;
            =======
            2 |     return false; // A comment
            >>>>>>> REPLACE
        expected:
          success: true
          content: "    return false; // A comment"

      - name: insertion-with-start-line
        description: Should insert code at a specific line when the search block is empty
        input:
          original_content: |
            function test() {
                const x = 1;
                return x;
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            =======
                console.log("Adding log");
            >>>>>>> REPLACE
          start_line: 2
          end_line: 2
        expected:
          success: true
          content: |
            function test() {
                console.log("Adding log");
                const x = 1;
                return x;
            }

      - name: insertion-fail-without-line-number
        description: Should fail an insertion if no start_line is provided
        input:
          original_content: "function test() {}"
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            =======
            console.log("test");
            >>>>>>> REPLACE
        expected:
          success: false
          reason: "Insertion requires a start_line"

      - name: deletion
        description: Should delete code when the replace block is empty
        input:
          original_content: |

            function test() {
                // Comment to remove
            }
          diff_content: |
            test.ts
            <<<<<<< SEARCH
                // Comment to remove
            =======
            >>>>>>> REPLACE
        expected:
          success: true
          content: |

            function test() {
            }

      - name: constrained-search-target-specific-duplicate
        description: Should use line numbers to target a specific instance of duplicate code
        input:
          original_content: |
            // Instance 1
            processData();

            // Instance 2
            processData();
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            processData();
            =======
            processData(config);
            >>>>>>> REPLACE
          start_line: 5
          end_line: 5
        expected:
          success: true
          content: |
            // Instance 1
            processData();

            // Instance 2
            processData(config);

      - name: multiple-blocks-in-one-call
        description: Should process multiple search/replace blocks in a single operation
        input:
          original_content: |
            const a = "apple";
            const b = "banana";
          diff_content: |
            test.ts
            <<<<<<< SEARCH
            const a = "apple";
            =======
            const a = "apricot";
            >>>>>>> REPLACE
            <<<<<<< SEARCH
            const b = "banana";
            =======
            const b = "blueberry";
            >>>>>>> REPLACE
        expected:
          success: true
          content: |
            const a = "apricot";
            const b = "blueberry";
  test/fixtures/standard-diff.yml: |-
    # Tests for the `getToolDescription` function
    tool_description_tests:
      - name: description-contains-key-elements
        description: Should generate a description that includes CWD and standard diff format markers
        input:
          cwd: "/mock/workspace"
        expected_to_contain:
          - "current working directory /mock/workspace"
          - "--- a/src/component.tsx"
          - "+++ b/src/component.tsx"
          - "@@ ... @@"

    # Tests for the `applyDiff` function
    apply_diff_tests:
      - name: simple-modification
        description: Should apply a simple modification, addition, and deletion correctly
        input:
          original_content: |
            line1
            line2
            line3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,4 @@
             line1
            +new line
             line2
            -line3
            +modified line3
        expected:
          success: true
          content: |
            line1
            new line
            line2
            modified line3

      - name: multiple-hunks
        description: Should correctly apply a diff with multiple, non-contiguous hunks
        input:
          original_content: |
            line1
            line2
            line3
            line4
            line5
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,2 +1,2 @@
             line1
            -line2
            +modified line2
            @@ -4,2 +4,2 @@
             line4
            -line5
            +modified line5
        expected:
          success: true
          content: |
            line1
            modified line2
            line3
            line4
            modified line5

      - name: correct-modification-with-similar-code
        description: Should correctly modify the right section when similar code exists elsewhere
        input:
          original_content: |
            function add(a, b) {
              return a + b;
            }

            function multiply(a, b) {
              return a + b;  // Bug here
            }
          diff_content: |
            --- a/math.js
            +++ b/math.js
            @@ -5,3 +5,3 @@
             function multiply(a, b) {
            -  return a + b;  // Bug here
            +  return a * b;
             }
        expected:
          success: true
          content: |
            function add(a, b) {
              return a + b;
            }

            function multiply(a, b) {
              return a * b;
            }

      - name: handle-indentation-changes
        description: Should correctly handle changes involving different types of indentation
        input:
          original_content: |
            function example() {
              let a = 1;
                let b = 2;
            }
          diff_content: |
            --- a/file.js
            +++ b/file.js
            @@ -1,4 +1,5 @@
             function example() {
               let a = 1;
            +  // new line
                 let b = 2;
             }
        expected:
          success: true
          content: |
            function example() {
              let a = 1;
              // new line
                let b = 2;
            }

      - name: handle-empty-lines-modification
        description: Should correctly apply changes that involve empty lines
        input:
          original_content: |
            line1

            line3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,3 @@
             line1
             
            -line3
            +line3-modified
        expected:
          success: true
          content: |
            line1

            line3-modified
      
      - name: fuzzy-match-with-drifted-context
        description: Should apply a hunk correctly even if the context has minor changes
        input:
          original_content: |
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.20;

            contract SimpleStore {
                uint256 private _value; // The value stored

                function setValue(uint256 value) public {
                    _value = value;
                }
            }
          diff_content: |
            --- a/SimpleStore.sol
            +++ b/SimpleStore.sol
            @@ -3,6 +3,10 @@
             
             contract SimpleStore {
                 uint256 private _value; // The value stored
            +
            +    function getValue() public view returns (uint256) {
            +        return _value;
            +    }
             
                 function setValue(uint256 value) public {
                     _value = value;
        expected:
          success: true
          content: |
            // SPDX-License-Identifier: MIT
            pragma solidity ^0.8.20;

            contract SimpleStore {
                uint256 private _value; // The value stored

                function getValue() public view returns (uint256) {
                    return _value;
                }

                function setValue(uint256 value) public {
                    _value = value;
                }
            }

      - name: fallback-hunk-splitting-on-failure
        description: Should split a failing hunk into smaller parts and apply them individually
        input:
          original_content: |
            import { readFile } from 'fs';
            import { Logger } from './logger';

            const logger = new Logger();

            async function processFile(filePath: string) {
              try {
                const data = await readFile(filePath, 'utf8');
                logger.info('File read successfully');
                return data;
              } catch (error) {
                logger.error('Failed to read file:', error);
                throw error;
              }
            }
          diff_content: |
            --- a/file.ts
            +++ b/file.ts
            @@ -1,13 +1,13 @@
             import { readFile } from 'fs';
            -import { Logger } from './logger';
            +import { Logger } from './utils/logger';
             
             const logger = new Logger(); // This context line is correct
             
             async function processFile(filePath: string) { // This context line is also correct
               try {
                 const data = await readFile(filePath, 'utf8');
            -    logger.info('File read successfully');
            +    logger.info(`File ${filePath} read successfully`);
                 return data;
               } catch (error) {
                 logger.error('Failed to read file:', error);
                 throw error;
               }
             }
        expected:
          success: true
          content: |
            import { readFile } from 'fs';
            import { Logger } from './utils/logger';

            const logger = new Logger();

            async function processFile(filePath: string) {
              try {
                const data = await readFile(filePath, 'utf8');
                logger.info(`File ${filePath} read successfully`);
                return data;
              } catch (error) {
                logger.error('Failed to read file:', error);
                throw error;
              }
            }

      - name: fail-on-non-existent-content
        description: Should fail when the diff context does not match the original content
        input:
          original_content: |
            line1
            line2
            line3
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,3 @@
             line1
            -nonexistent line
            +new line
             line3
        expected:
          success: false
          reason: "Could not apply modification"

      - name: fail-on-overlapping-hunks
        description: Should fail to apply diffs that contain overlapping hunks
        input:
          original_content: |
            line1
            line2
            line3
            line4
            line5
          diff_content: |
            --- a/file.txt
            +++ b/file.txt
            @@ -1,3 +1,3 @@
             line1
             line2
            -line3
            +modified3
            @@ -2,3 +2,2 @@
             line2
            -line3
            -line4
            +modified3and4
        expected:
          success: false
          reason: "Hunks overlap"
approved: true
